../patch/collapse/clump_finder.f90
subroutine clump_finder(create_output,keep_alive)
  use amr_commons
  use poisson_commons, ONLY:phi,rho
  use clfind_commons
  use hydro_commons
  implicit none
#ifndef WITHOUTMPI
  include 'mpif.h'
#endif
  logical::create_output,keep_alive

  !----------------------------------------------------------------------------
  ! Description of clump_finder:
  ! The clumpfinder detect first all cells having a density above
  ! a given threshold. These cells are linked to their densest neighbors,
  ! defining a peak patch around each local density maximum. 
  ! If a so called peak patch is considered irrelevant, it is merged to its 
  ! neighboring peak patch with the highest saddle density.
  ! Parameters are read in a namelist and they are:
  ! - density_threshold: defines the cell population to consider
  ! - relevance_threshold: merge peaks that are considered as ``noise''
  ! - saddle_threshold: for cosmo runs, merge peaks into halos (HOP-style)
  ! - mass_threshold: output only clumps (or halos) above this mass
  ! Andreas Bleuler & Davide Martizzi & Romain Teyssier
  !----------------------------------------------------------------------------

  integer::istep,nskip,ilevel,info,icpu,nmove,nzero
  integer::i,j,peak_nr, levelmin_part
  integer(i8b)::ntest_all,nmove_all,nmove_tot,nzero_all,nzero_tot
  integer(i8b),dimension(1:ncpu)::ntest_cpu,ntest_cpu_all
  integer,dimension(1:ncpu)::npeaks_per_cpu_tot
  logical::all_bound

  if(verbose.and.myid==1)write(*,*)' Entering clump_finder'

  ! When called from the create_sink, particles are all residing at level 1, 
  ! otherwise at levelmin.
  
  if (create_output)then
     levelmin_part = levelmin
  else
     levelmin_part = 1
  end if

  !---------------------------------------------------------------
  ! Compute rho from gas density or dark matter particles
  !---------------------------------------------------------------
  if(ivar_clump==0)then
     do ilevel=levelmin_part,nlevelmax
        if(pic)call make_tree_fine(ilevel)
        if(poisson)call rho_only(ilevel)
        if(pic)then
           call kill_tree_fine(ilevel)
           call virtual_tree_fine(ilevel)
        endif
     end do
     do ilevel=nlevelmax,levelmin_part,-1
        if(pic)call merge_tree_fine(ilevel)
     end do
  endif

  !------------------------------------------------------------------------
  ! count the number of cells with density above the threshold
  ! flag the cells, share info across processors
  !------------------------------------------------------------------------
  ntest=0
  do ilevel=levelmin,nlevelmax
     if(ivar_clump==0)then ! action 1: count and flag
        call count_test_particle(rho(1),ilevel,0,1) 
     else
        if(hydro)then      ! action 1: count and flag
           call count_test_particle(uold(1,ivar_clump),ilevel,0,1)
        endif
     end if
  end do
  ntest_cpu=0; ntest_cpu_all=0
  ntest_cpu(myid)=ntest
#ifndef WITHOUTMPI
#ifndef LONGINT
  call MPI_ALLREDUCE(ntest_cpu,ntest_cpu_all,ncpu,MPI_INTEGER,MPI_SUM,MPI_COMM_WORLD,info)
#else
  call MPI_ALLREDUCE(ntest_cpu,ntest_cpu_all,ncpu,MPI_INTEGER8,MPI_SUM,MPI_COMM_WORLD,info)
#endif
  ntest_cpu(1)=ntest_cpu_all(1)
#endif
  do icpu=2,ncpu
     ntest_cpu(icpu)=ntest_cpu(icpu-1)+ntest_cpu_all(icpu)
  end do
  ntest_all=ntest_cpu(ncpu)
  if(myid==1)then
     if(ntest_all.gt.0.and.clinfo)then
        write(*,'(' Total number of cells above threshold=',I12)')ntest_all
     endif
  end if

  !------------------------------------------------------------------------
  ! Allocate arrays and create list of cells above the threshold
  !------------------------------------------------------------------------
  if (ntest>0) then 
     allocate(denp(ntest),levp(ntest),imaxp(ntest),icellp(ntest))
     denp=0.d0; levp=0; imaxp=0; icellp=0
  endif
  itest=0
  nskip=ntest_cpu(myid)-ntest
  do ilevel=levelmin,nlevelmax
     if(ivar_clump==0)then
        call count_test_particle(rho(1),ilevel,nskip,2)
     else
        if(hydro)then
           call count_test_particle(uold(1,ivar_clump),ilevel,nskip,2)
        endif
     endif
  end do
  do ilevel=nlevelmax,levelmin,-1
     call make_virtual_fine_int(flag2(1),ilevel)
  end do

  !-----------------------------------------------------------------------
  ! Sort cells above threshold according to their density
  !-----------------------------------------------------------------------
  if (ntest>0) then
     allocate(testp_sort(ntest)) 
     do i=1,ntest
        denp(i)=-denp(i)
        testp_sort(i)=i
     end do
     call quick_sort_dp(denp(1),testp_sort(1),ntest) 
     deallocate(denp)
  endif

  !-----------------------------------------------------------------------
  ! Count number of density peaks and share info across processors 
  !-----------------------------------------------------------------------
  npeaks=0
  if(ntest>0)then
     if(ivar_clump==0)then  ! case 1: count peaks
        call count_peaks(rho(1),npeaks)
     else
        if(hydro)then       ! case 1: count peaks
           call count_peaks(uold(1,ivar_clump),npeaks)
        endif
     endif
  endif
  allocate(npeaks_per_cpu(1:ncpu))
  allocate(ipeak_start(1:ncpu))
  npeaks_per_cpu=0
  npeaks_per_cpu(myid)=npeaks
#ifndef WITHOUTMPI
  call MPI_ALLREDUCE(npeaks_per_cpu,npeaks_per_cpu_tot,ncpu,MPI_INTEGER,MPI_SUM,MPI_COMM_WORLD,info)
#endif
#ifdef WITHOUTMPI
  npeaks_per_cpu_tot=npeaks_per_cpu
#endif
#ifndef WITHOUTMPI
  call MPI_ALLREDUCE(npeaks,npeaks_tot,1,MPI_INTEGER,MPI_SUM,MPI_COMM_WORLD,info)
#endif
#ifdef WITHOUTMPI
  npeaks_tot=npeaks
#endif
  if (myid==1.and.npeaks_tot>0) &
       & write(*,'(' Total number of density peaks found=',I10)')npeaks_tot
  
  !----------------------------------------------------------------------
  ! Determine peak-ids positions for each cpu
  !----------------------------------------------------------------------
  ipeak_start=0
  npeaks_per_cpu=npeaks_per_cpu_tot
  do icpu=2,ncpu
     ipeak_start(icpu)=ipeak_start(icpu-1)+npeaks_per_cpu(icpu-1)
  end do
  nskip=ipeak_start(myid)

  !----------------------------------------------------------------------
  ! Flag peaks with global peak id using flag2 array
  ! Compute peak density using max_dens array
  !----------------------------------------------------------------------

  ! Compute the size of the peak-based arrays
  npeaks_max=MAX(4*maxval(npeaks_per_cpu_tot),1000)
  allocate(max_dens(npeaks_max))
  allocate(dens_jeans(npeaks_max))
  allocate(peak_cell(npeaks_max))
  allocate(peak_cell_level(npeaks_max))
  max_dens=0.d0; peak_cell=0; peak_cell_level=0; dens_jeans=0.d0
  flag2=0
  if(ntest>0)then
     if(ivar_clump==0)then
        call flag_peaks(rho(1),nskip)
     else
        if(hydro)then
           call flag_peaks(uold(1,ivar_clump),nskip)
        endif
     endif
  endif
  do ilevel=nlevelmax,levelmin,-1
     call make_virtual_fine_int(flag2(1),ilevel)
  end do

  !---------------------------------------------------------------------
  ! Determine peak-patches around each peak
  ! Main step: 
  ! - order cells in descending density
  ! - get peak id from densest neighbor
  ! - nmove is number of peak id's passed along
  ! - done when nmove_tot=0 (for single core, only one sweep is necessary)
  !---------------------------------------------------------------------
  if (myid==1.and.ntest_all>0)write(*,*)'Finding peak patches'
  nmove_tot=1
  istep=0
  do while (nmove_tot.gt.0)
     nmove=0
     nzero=0
     if(ntest>0)then
        call propagate_flag(nmove,nzero)
     endif
     do ilevel=nlevelmax,levelmin,-1
        call make_virtual_fine_int(flag2(1),ilevel)
     end do
     istep=istep+1
     nmove_tot=nmove
     nzero_tot=nzero
#ifndef WITHOUTMPI 
#ifndef LONGINT
     call MPI_ALLREDUCE(nmove_tot,nmove_all,1,MPI_INTEGER,MPI_SUM,MPI_COMM_WORLD,info)
     call MPI_ALLREDUCE(nzero_tot,nzero_all,1,MPI_INTEGER,MPI_SUM,MPI_COMM_WORLD,info)
#else
     call MPI_ALLREDUCE(nmove_tot,nmove_all,1,MPI_INTEGER8,MPI_SUM,MPI_COMM_WORLD,info)
     call MPI_ALLREDUCE(nzero_tot,nzero_all,1,MPI_INTEGER8,MPI_SUM,MPI_COMM_WORLD,info)
#endif
     nmove_tot=nmove_all
     nzero_tot=nzero_all
#endif   
     if(myid==1.and.ntest_all>0.and.clinfo)write(*,*)'istep=',istep,'nmove=',nmove_tot
  end do

  !------------------------------------
  ! Allocate peak-patch property arrays
  !------------------------------------
  call allocate_peak_patch_arrays
  call build_peak_communicator

  if(npeaks_tot > 0)then
     !------------------------------------------
     ! Compute the saddle point density matrix
     !------------------------------------------
     if(ivar_clump==0)then
        call saddlepoint_search(rho(1)) 
     else
        if(hydro)then
           call saddlepoint_search(uold(1,ivar_clump))
        endif
     endif
     call build_peak_communicator

     !------------------------------------------
     ! Merge irrelevant peaks
     !------------------------------------------
     if(myid==1.and.clinfo)write(*,*)'Now merging irrelevant peaks.'
     call merge_clumps('relevance')
     do ilevel=nlevelmax,levelmin,-1
        call make_virtual_fine_int(flag2(1),ilevel)
     end do

     !------------------------------------------
     ! Compute clumps properties
     !------------------------------------------
     if(myid==1.and.clinfo)write(*,*)'Computing relevant clump properties.'
     if(ivar_clump==0)then
        call compute_clump_properties(rho(1))
     else
        if(hydro)then
           call compute_clump_properties(uold(1,ivar_clump))
        endif
     endif
     
     !------------------------------------------
     ! Merge clumps into haloes
     !------------------------------------------
     if(saddle_threshold>0)then
        if(myid==1.and.clinfo)write(*,*)'Now merging peaks into halos.'
        call merge_clumps('saddleden')
     endif

     !------------------------------------------
     ! Output clumps properties to file
     !------------------------------------------
     if(myid==1.and.clinfo)then
        write(*,*)'Output status of peak memory.'
     endif
     if(clinfo)call analyze_peak_memory
     if(clinfo.and.saddle_threshold.LE.0)call write_clump_properties(.false.)
     if(create_output)then
        if(myid==1)write(*,*)'Outputing clump properties to disc.'
        call write_clump_properties(.true.)
     endif
     ! Output diagnostic files for clumps/sinks every step?
     if (output_clumps)then
        call write_clumps_each_step
     endif

     
  end if

  if (.not. keep_alive)then
     ! Deallocate test particle and peak arrays
     deallocate(npeaks_per_cpu)
     deallocate(ipeak_start)
     if (ntest>0)then
        deallocate(icellp)
        deallocate(levp)
        deallocate(testp_sort)
        deallocate(imaxp)
     endif
     call deallocate_all
  end if

end subroutine clump_finder
!################################################################
!################################################################
!################################################################
!################################################################
subroutine count_test_particle(xx,ilevel,nskip,action)
  use amr_commons
  use clfind_commons
  implicit none
#ifndef WITHOUTMPI
  include 'mpif.h'
#endif
  integer::ilevel,nskip,action
  real(dp),dimension(1:ncoarse+ngridmax*twotondim)::xx

  !----------------------------------------------------------------------
  ! Description: This routine loops over all cells above and checks wether
  ! their density lies above the threshold. If so:
  ! case 1: count the new test particles and flag the cell
  ! case 2: create the test particle
  ! xx is on input the array containing the density field
  !----------------------------------------------------------------------

  integer ::ncache,ngrid
  integer ::igrid,ind,i,iskip
  integer ,dimension(1:nvector)::ind_grid,ind_cell
  logical ,dimension(1:nvector)::ok


  if(numbtot(1,ilevel)==0) return

  if(verbose .and. myid==1)then
     write(*,*)' Entering count test particle for level=',& 
          & ilevel,' and action=',action
  endif

  ! Loop over grids
  ncache=active(ilevel)%ngrid
  do igrid=1,ncache,nvector
     ngrid=MIN(nvector,ncache-igrid+1)
     do i=1,ngrid
        ind_grid(i)=active(ilevel)%igrid(igrid+i-1)
     end do
     ! loop over cells
     do ind=1,twotondim
        iskip=ncoarse+(ind-1)*ngridmax
        do i=1,ngrid
           ind_cell(i)=iskip+ind_grid(i)
        end do

        !checks
        do i=1,ngrid
           ok(i)=son(ind_cell(i))==0 !check if leaf cell
           ok(i)=ok(i).and.xx(ind_cell(i))>density_threshold !check density
        end do

        select case (action) 
        case (1) !count and flag
           ! Compute test particle map
           do i=1,ngrid
              flag2(ind_cell(i))=0
              if(ok(i))then
                 flag2(ind_cell(i))=1 
                 ntest=ntest+1
              endif
           end do
        case(2) !create 'testparticles'
           do i=1,ngrid
              if (ok(i))then
                 itest=itest+1                   ! Local 'test particle' index
                 levp(itest)=ilevel              ! Level
                 flag2(ind_cell(i))=itest+nskip  ! Initialize flag2 to GLOBAL test particle index
                 icellp(itest)=ind_cell(i)       ! Local cell index
                 denp(itest)=xx(ind_cell(i))     ! Save density values here!
              end if
           end do
        end select
     end do
  end do

end subroutine count_test_particle
!################################################################
!################################################################
!################################################################
!################################################################
subroutine count_peaks(xx,n)
  use amr_commons
  use clfind_commons
  implicit none
#ifndef WITHOUTMPI
  include 'mpif.h' 
#endif
  integer::n
  real(dp),dimension(1:ncoarse+ngridmax*twotondim)::xx
  !----------------------------------------------------------------------
  ! Count the peaks (cell with no denser neighbor)
  ! Store the index of the densest neighbor (can be the cell itself)
  ! for later usage.
  !----------------------------------------------------------------------
  integer::ilevel,next_level,ipart,jpart,ip
  integer,dimension(1:nvector)::ind_part,ind_cell,ind_max

  if(verbose .and. myid==1)then
     write(*,*)' Entering count peaks'
  endif
  
  ! Group chunks of nvector cells (of the same level) and send them 
  ! to the routine that constructs the neighboring cells
  ip=0
  do ipart=1,ntest
     ip=ip+1
     ilevel=levp(testp_sort(ipart))  ! level
     next_level=0                    ! level of next particle
     if(ipart<ntest)next_level=levp(testp_sort(ipart+1))
     ind_cell(ip)=icellp(testp_sort(ipart))
     ind_part(ip)=testp_sort(ipart)
     if(ip==nvector .or. next_level /= ilevel)then
        call neighborsearch(xx(1),ind_cell,ind_max,ip,n,ilevel,1)
        do jpart=1,ip
           imaxp(ind_part(jpart))=ind_max(jpart)
        end do
        ip=0
     endif
  end do
  if (ip>0)then
     call neighborsearch(xx(1),ind_cell,ind_max,ip,n,ilevel,1)
     do jpart=1,ip
        imaxp(ind_part(jpart))=ind_max(jpart)
     end do
  endif

end subroutine count_peaks
!#########################################################################
!#########################################################################
!#########################################################################
!#########################################################################
subroutine flag_peaks(xx,ipeak)
  use amr_commons
  use clfind_commons
  implicit none
#ifndef WITHOUTMPI
  include 'mpif.h' 
#endif
  integer::ipeak
  real(dp),dimension(1:ncoarse+ngridmax*twotondim)::xx
  !----------------------------------------------------------------------
  ! Flag (flag2 array) all cells that host a peak with the global peak id
  !----------------------------------------------------------------------
  integer::ipart,jpart
  integer,dimension(1:nvector)::ind_part,ind_cell,ind_max
  do ipart=1,ntest
     jpart=testp_sort(ipart)
     if(imaxp(jpart).EQ.-1)then
        ipeak=ipeak+1
        flag2(icellp(jpart))=ipeak
        max_dens(ipeak-ipeak_start(myid))=xx(icellp(jpart))
        peak_cell(ipeak-ipeak_start(myid))=icellp(jpart)
        peak_cell_level(ipeak-ipeak_start(myid))=levp(jpart)
     endif
  end do
end subroutine flag_peaks
!#########################################################################
!#########################################################################
!#########################################################################
!#########################################################################
subroutine propagate_flag(nmove,nzero)
  use amr_commons
  use clfind_commons
  implicit none
#ifndef WITHOUTMPI
  include 'mpif.h' 
#endif
  integer::nmove,nzero
  !----------------------------------------------------------------------
  ! All cells above the threshold copy the flag2 value from their densest
  ! neighbors. Because of MPI boundaries, flag2=0 can be passed around.
  ! Once all flag2=0 values have disappiered (globally), we're done.
  !----------------------------------------------------------------------
  integer::ipart,jpart
  do ipart=1,ntest
     jpart=testp_sort(ipart)
     if(imaxp(jpart).NE.-1)then
        if(flag2(icellp(jpart)).ne.flag2(imaxp(jpart)))nmove=nmove+1
        flag2(icellp(jpart))=flag2(imaxp(jpart))
        if(flag2(icellp(jpart)).eq.0)nzero=nzero+1
     endif
  end do
end subroutine propagate_flag
!#########################################################################
!#########################################################################
!#########################################################################
!#########################################################################
subroutine saddlepoint_search(xx)
  use amr_commons
  use clfind_commons
  implicit none
#ifndef WITHOUTMPI
  include 'mpif.h'
#endif
  real(dp),dimension(1:ncoarse+ngridmax*twotondim)::xx
  !---------------------------------------------------------------------------
  ! subroutine which creates a npeaks**2 sized array of saddlepoint densities
  ! by looping over all testparticles and passing them to neighborcheck with
  ! case 4, which means that saddlecheck will be called for each neighboring
  ! leaf cell. There it is checked, whether the two cells (original cell and
  ! neighboring cell) are connected by a new densest saddle.
  !---------------------------------------------------------------------------
  integer::ipart,ip,ilevel,next_level
  integer::i,j,info,dummyint
  integer,dimension(1:nvector)::ind_cell,ind_max

  ip=0
  do ipart=1,ntest
     ip=ip+1
     ilevel=levp(testp_sort(ipart)) ! level
     next_level=0 !level of next particle
     if(ipart<ntest)next_level=levp(testp_sort(ipart+1))
     ind_cell(ip)=icellp(testp_sort(ipart))
     if(ip==nvector .or. next_level /= ilevel)then
        call neighborsearch(xx(1),ind_cell,ind_max,ip,dummyint,ilevel,4)
        ip=0
     endif
  end do
  if (ip>0)call neighborsearch(xx(1),ind_cell,ind_max,ip,dummyint,ilevel,4)

end subroutine saddlepoint_search
!#########################################################################
!#########################################################################
!#########################################################################
!#########################################################################
subroutine neighborsearch(xx,ind_cell,ind_max,np,count,ilevel,action)
  use amr_commons
  use clfind_commons,ONLY:ipeak_start
  implicit none
  integer::np,count,ilevel,action
  integer,dimension(1:nvector)::ind_max,ind_cell
  real(dp),dimension(1:ncoarse+ngridmax*twotondim)::xx

  !------------------------------------------------------------
  ! This routine constructs all neighboring leaf cells at levels 
  ! ilevel-1, ilevel, ilevel+1.
  ! Depending on the action case value, fuctions performing
  ! further checks for the neighbor cells are called.
  ! xx is on input the array containing the density field  
  !------------------------------------------------------------

  integer::j,ind,nx_loc,i1,j1,k1,i2,j2,k2,i3,j3,k3,ix,iy,iz
  integer::i1min,i1max,j1min,j1max,k1min,k1max
  integer::i2min,i2max,j2min,j2max,k2min,k2max
  integer::i3min,i3max,j3min,j3max,k3min,k3max
  real(dp)::dx,dx_loc,scale,vol_loc
  integer ,dimension(1:nvector)::clump_nr,indv,ind_grid,grid,ind_cell_coarse

  real(dp),dimension(1:twotondim,1:3)::xc
  integer ,dimension(1:99)::cell_index,cell_levl,test_levl
  real(dp),dimension(1:99,1:ndim)::xtest,xrel
  logical ,dimension(1:99)::ok
  real(dp),dimension(1:nvector)::density_max
  real(dp),dimension(1:3)::skip_loc
  logical ,dimension(1:nvector)::okpeak,okdummy
  integer ,dimension(1:nvector,1:threetondim),save::nbors_father_cells
  integer ,dimension(1:nvector,1:twotondim),save::nbors_father_grids 
  integer::ntestpos,ntp,idim,ipos



#if NDIM==3
  ! Mesh spacing in that level
  dx=0.5D0**ilevel 
  nx_loc=(icoarse_max-icoarse_min+1)
  skip_loc=(/0.0d0,0.0d0,0.0d0/)
  if(ndim>0)skip_loc(1)=dble(icoarse_min)
  if(ndim>1)skip_loc(2)=dble(jcoarse_min)
  if(ndim>2)skip_loc(3)=dble(kcoarse_min)
  scale=boxlen/dble(nx_loc)
  dx_loc=dx*scale
  vol_loc=dx_loc**3

  ! Integer constants
  i1min=0; i1max=0; i2min=0; i2max=0; i3min=0; i3max=0
  j1min=0; j1max=0; j2min=0; j2max=0; j3min=0; j3max=0
  k1min=0; k1max=0; k2min=0; k2max=0; k3min=0; k3max=0
  if(ndim>0)then
     i1max=1; i2max=2; i3max=3
  end if
  if(ndim>1)then
     j1max=1; j2max=2; j3max=3
  end if
  if(ndim>2)then
     k1max=1; k2max=2; k3max=3
  end if

  ! Cells center position relative to grid center position
  do ind=1,twotondim
     iz=(ind-1)/4
     iy=(ind-1-4*iz)/2
     ix=(ind-1-2*iy-4*iz)
     xc(ind,1)=(dble(ix)-0.5D0)*dx
     xc(ind,2)=(dble(iy)-0.5D0)*dx
     xc(ind,3)=(dble(iz)-0.5D0)*dx
  end do
  
  ! some preliminary action...
  do j=1,np
     indv(j)=(ind_cell(j)-ncoarse-1)/ngridmax+1 ! cell position in grid
     ind_grid(j)=ind_cell(j)-ncoarse-(indv(j)-1)*ngridmax ! grid index
     density_max(j)=xx(ind_cell(j))*1.0001 ! get cell density (1.0001 probably not necessary)
     ind_max(j)=ind_cell(j) !save cell index   
     if (action.ge.4)clump_nr(j)=flag2(ind_cell(j)) ! save clump number
  end do




  ntestpos=3**ndim
  if(ilevel>levelmin)ntestpos=ntestpos+2**ndim
  if(ilevel<nlevelmax)ntestpos=ntestpos+4**ndim

  !================================
  ! generate neighbors level ilevel-1
  !================================
  ntp=0
  if(ilevel>levelmin)then
     ! Generate 2x2x2  neighboring cells at level ilevel-1     
     do k1=k1min,k1max
        do j1=j1min,j1max
           do i1=i1min,i1max                                            
              ntp=ntp+1
              xrel(ntp,1)=(2*i1-1)*dx_loc
              xrel(ntp,2)=(2*j1-1)*dx_loc
              xrel(ntp,3)=(2*k1-1)*dx_loc
              test_levl(ntp)=ilevel-1
           end do
        end do
     end do
  endif

  !================================
  ! generate neighbors at level ilevel
  !================================
  ! Generate 3x3x3 neighboring cells at level ilevel
  do k2=k2min,k2max
     do j2=j2min,j2max
        do i2=i2min,i2max
           ntp=ntp+1
           xrel(ntp,1)=(i2-1)*dx_loc
           xrel(ntp,2)=(j2-1)*dx_loc
           xrel(ntp,3)=(k2-1)*dx_loc
           test_levl(ntp)=ilevel
        end do
     end do
  end do
  
  !===================================
  ! generate neighbors at level ilevel+1
  !====================================
  if(ilevel<nlevelmax)then
     ! Generate 4x4x4 neighboring cells at level ilevel+1
     do k3=k3min,k3max
        do j3=j3min,j3max
           do i3=i3min,i3max
              ntp=ntp+1
              xrel(ntp,1)=(i3-1.5)*dx_loc/2.0
              xrel(ntp,2)=(j3-1.5)*dx_loc/2.0
              xrel(ntp,3)=(k3-1.5)*dx_loc/2.0
              test_levl(ntp)=ilevel+1
           end do
        end do
     end do
  endif



  ! Gather 27 neighboring father cells (should be present anytime !)
  do j=1,np
     ind_cell_coarse(j)=father(ind_grid(j))
  end do
  call get3cubefather(ind_cell_coarse,nbors_father_cells,nbors_father_grids,np,ilevel)


  ! initialze logical array
  okpeak=.true.
  
  do j=1,np
     ok=.false.
     do idim=1,ndim
        xtest(1:ntestpos,idim)=(xg(ind_grid(j),idim)+xc(indv(j),idim)-skip_loc(idim))*scale+xrel(1:ntestpos,idim)
        if(ilevel>levelmin)xtest(1:twotondim,idim)=xtest(1:twotondim,idim)+xc(indv(j),idim)*scale
     end do
     grid(1)=ind_grid(j)
     call get_cell_index_fast(cell_index,cell_levl,xtest,ind_grid(j),nbors_father_cells(j,1:threetondim),ntestpos,ilevel)
     
     do ipos=1,ntestpos
        if(son(cell_index(ipos))==0.and.cell_levl(ipos)==test_levl(ipos))ok(ipos)=.true.
     end do
     
     ! check those neighbors
     if (action==1)call peakcheck(xx(1),cell_index,okpeak(j),ok,density_max(j),ind_max(j),ntestpos)
     if (action==4)call saddlecheck(xx(1),ind_cell(j),cell_index,clump_nr(j),ok,ntestpos)
     
  end do
     
  ! Count peaks (only one action case left as case 2 and 3 are dealt with 
  ! outside neighborsearch
  if (action==1) then
     do j=1,np
        if(okpeak(j))then
           count=count+1
           ind_max(j)=-1
        endif
     end do  
  end if

#endif

end subroutine neighborsearch
!#########################################################################
!#########################################################################
!#########################################################################
!#########################################################################
subroutine peakcheck(xx,cell_index,okpeak,ok,density_max,ind_max,np)
  use amr_commons
  implicit none
  !----------------------------------------------------------------------
  ! routine to check wether neighbor is denser or not
  !----------------------------------------------------------------------
  logical,dimension(1:99)::ok
  logical::okpeak
  integer,dimension(1:99)::cell_index
  integer::ind_max
  real(dp)::density_max
  real(dp),dimension(1:ncoarse+ngridmax*twotondim)::xx
  integer::np,j


  do j=1,np           
     ! only consider leaf-cells at correct level                   
     if(ok(j))then    
        ! if cell is denser than densest neighbor
        if(xx(cell_index(j))>density_max)then  
           okpeak=.false.                 ! cell is no peak
           density_max=xx(cell_index(j))  ! change densest neighbor dens
           ind_max=cell_index(j)          ! change densest neighbor index
        endif
     end if
  end do

end subroutine peakcheck
!#########################################################################
!#########################################################################
!#########################################################################
!#########################################################################
subroutine saddlecheck(xx,ind_cell,cell_index,clump_nr,ok,np)
  use amr_commons
  use clfind_commons, ONLY: sparse_saddle_dens
  use sparse_matrix
  implicit none
  !----------------------------------------------------------------------
  ! routine to check wether neighbor is connected through new densest saddle
  !----------------------------------------------------------------------
  logical,dimension(1:99)::ok
  integer,dimension(1:99)::cell_index,neigh_cl
  real(dp),dimension(1:99)::av_dens
  real(dp),dimension(1:ncoarse+ngridmax*twotondim)::xx
  integer::np,j,ipeak,jpeak,clump_nr,ind_cell

  do j=1,np
     neigh_cl(j)=flag2(cell_index(j))!index of the clump the neighboring cell is in 
  end do
  do j=1,np
     ok(j)=ok(j).and. clump_nr/=0 ! temporary fix...
     ok(j)=ok(j).and. neigh_cl(j)/=0 !neighboring cell is in a clump
     ok(j)=ok(j).and. neigh_cl(j)/=clump_nr !neighboring cell is in another clump
     av_dens(j)=(xx(cell_index(j))+xx(ind_cell))*0.5 !average density of cell and neighbor cell
  end do
  do j=1,np
     if(ok(j))then ! if all criteria met, replace saddle density array value
        call get_local_peak_id(clump_nr,ipeak)
        call get_local_peak_id(neigh_cl(j),jpeak)
        if (get_value(ipeak,jpeak,sparse_saddle_dens) < av_dens(j))then
           call set_value(ipeak,jpeak,av_dens(j),sparse_saddle_dens)
        end if
        if (get_value(jpeak,ipeak,sparse_saddle_dens) < av_dens(j))then
           call set_value(jpeak,ipeak,av_dens(j),sparse_saddle_dens)
        end if
     end if
  end do

end subroutine saddlecheck
!#########################################################################
!#########################################################################
!#########################################################################
!#########################################################################
subroutine get_cell_index(cell_index,cell_levl,xpart,ilevel,n)
  use amr_commons
  implicit none

  integer::n,ilevel
  integer,dimension(1:nvector)::cell_index,cell_levl
  real(dp),dimension(1:nvector,1:3)::xpart

  !----------------------------------------------------------------------------
  ! This routine returns the index and level of the cell, (at maximum level
  ! ilevel), in which the input the position specified by xpart lies
  !----------------------------------------------------------------------------

  real(dp)::xx,yy,zz
  integer::i,j,ii,jj,kk,ind,iskip,igrid,ind_cell,igrid0

!commented by PH 
!seems to be alright so far
!  if ((nx.eq.1).and.(ny.eq.1).and.(nz.eq.1)) then
!  else if ((nx.eq.3).and.(ny.eq.3).and.(nz.eq.3)) then
!  else
!     write(*,*)'nx=ny=nz != 1,3 is not supported.'
!     call clean_stop
!  end if

  ind_cell=0
  igrid0=son(1+icoarse_min+jcoarse_min*nx+kcoarse_min*nx*ny)
  do i=1,n
     xx = xpart(i,1)/boxlen + (nx-1)/2.0
     yy = xpart(i,2)/boxlen + (ny-1)/2.0
     zz = xpart(i,3)/boxlen + (nz-1)/2.0

     if(xx<0.)xx=xx+dble(nx)
     if(xx>dble(nx))xx=xx-dble(nx)
     if(yy<0.)yy=yy+dble(ny)
     if(yy>dble(ny))yy=yy-dble(ny)
     if(zz<0.)zz=zz+dble(nz)
     if(zz>dble(nz))zz=zz-dble(nz)

     igrid=igrid0
     do j=1,ilevel 
        ii=1; jj=1; kk=1
        if(xx<xg(igrid,1))ii=0
        if(yy<xg(igrid,2))jj=0
        if(zz<xg(igrid,3))kk=0
        ind=1+ii+2*jj+4*kk
        iskip=ncoarse+(ind-1)*ngridmax
        ind_cell=iskip+igrid
        igrid=son(ind_cell)
        if(igrid==0.or.j==ilevel)exit
     end do
     cell_index(i)=ind_cell
     cell_levl(i)=j
  end do
end subroutine get_cell_index
!#########################################################################
!#########################################################################
!#########################################################################
!#########################################################################
subroutine read_clumpfind_params()
  use clfind_commons
  implicit none
#ifndef WITHOUTMPI
  include 'mpif.h'
#endif

  namelist/clumpfind_params/ivar_clump,& 
       & relevance_threshold,density_threshold,&
       & saddle_threshold,mass_threshold,clinfo,&
       & n_clfind,rho_clfind,age_cut_clfind,output_clumps
  real(dp)::scale_nH,scale_T2,scale_l,scale_d,scale_t,scale_v,scale_m  
  
  ! Read namelist file 
  rewind(1)
  read(1,NML=clumpfind_params,END=121)
  goto 122
121 if(myid==1)write(*,*)'You did not set up namelist &CLUMPFIND_PARAMS in parameter file.'

  if (.not. sink)then 
     if(myid==1)write(*,*)'That block should a least contain a density '
     if(myid==1)write(*,*)'threshold n_clfind [parts/cc] or rho_clfind [g/cc]!'
     if(myid==1)write(*,*)'aborting...'
     call clean_stop
  end if

122 rewind(1)

  if (density_threshold>0.)then
     if (rho_clfind>0. .or. n_clfind >0.)then     
        if(myid==1)write(*,*)'you provided the density threshold in code units.'
        if(myid==1)write(*,*)'Ignoring the input in physical units...'
     end if
  else
     if (cosmo) then
        if(myid==1)write(*,*)'For cosmological simulations you have to specify the'
        if(myid==1)write(*,*)'clumpfinder density threshold in code units.'
        call clean_stop
     end if
     call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)
     if (rho_clfind>0. .and. n_clfind >0.)then   ! too much information...
        if(myid==1)write(*,*)'you set up the clumpfinder threshold in both, H/cc and g/cc, decide!'
        if(myid==1)write(*,*)'aborting...'
        call clean_stop
     else if (rho_clfind<0. .and. n_clfind <0.)then  !not enough information
        if (sink)then
           density_threshold=d_sink/10.
           if(myid==1)write(*,*)'You did not specify a threshold for the clump finder. '
           if(myid==1)write(*,*)'Setting it to sink threshold / 10. !'
        else
           if(myid==1)write(*,*)'The &CLUMPFIND_PARAMS block should a least contain '
           if(myid==1)write(*,*)'density_threshold [code units], n_clfind [parts/cc]'
           if(myid==1)write(*,*)'or rho_clfind [g/cc]!'
           if(myid==1)write(*,*)'aborting...'
           call clean_stop
        end if
     else if (n_clfind>0.)then
        density_threshold=n_clfind/scale_nH
     else if(rho_clfind>0.)then
        density_threshold=rho_clfind/scale_d
     end if
  end if
end subroutine read_clumpfind_params

!################################################################
!################################################################
!################################################################
!################################################################
subroutine get_cell_index_fast(indp,cell_lev,xpart,ind_grid,nbors_father_cells,np,ilevel)
  use amr_commons
  use pm_commons
  use hydro_commons
  implicit none
  integer::ng,np,ilevel,ind_grid
  integer,dimension(1:99)::indp,cell_lev
  real(dp),dimension(1:99,1:ndim)::xpart
  integer ,dimension(1:threetondim)::nbors_father_cells


  !-----------------------------------------------------------------------
  ! Very similar as get_cell_index_for_particle but optimized for the usage
  ! inside neighborsearch.
  !-----------------------------------------------------------------------

  integer::i,j,idim,nx_loc,ind,ix,iy,iz
  real(dp)::dx,dx_loc,scale,one_over_dx,one_over_scale
  ! Grid based arrays
  real(dp),dimension(1:ndim),save::x0
  real(dp),dimension(1:99,1:ndim),save::x
  integer ,dimension(1:99,1:ndim),save::id,igd,icd,icd_fine
  integer ,dimension(1:99),save::igrid,icell,kg,icell_fine
  real(dp),dimension(1:3),save::skip_loc
  real(dp),dimension(1:twotondim,1:3),save::xc
  logical,dimension(1:99),save::ok
 

  ! Mesh spacing in that level
  dx=0.5D0**ilevel
  nx_loc=(icoarse_max-icoarse_min+1)
  skip_loc=(/0.0d0,0.0d0,0.0d0/)
  if(ndim>0)skip_loc(1)=dble(icoarse_min)
  if(ndim>1)skip_loc(2)=dble(jcoarse_min)
  if(ndim>2)skip_loc(3)=dble(kcoarse_min)
  scale=boxlen/dble(nx_loc)
  dx_loc=dx*scale
  one_over_dx=1./dx
  one_over_scale=1./scale

  ! Cells center position relative to grid center position
  do ind=1,twotondim
     iz=(ind-1)/4
     iy=(ind-1-4*iz)/2
     ix=(ind-1-2*iy-4*iz)
     xc(ind,1)=(dble(ix)-0.5D0)*dx
     xc(ind,2)=(dble(iy)-0.5D0)*dx
     xc(ind,3)=(dble(iz)-0.5D0)*dx
  end do

  ! Lower left corner of 3x3x3 grid-cube
  do idim=1,ndim
        x0(idim)=xg(ind_grid,idim)-3.0D0*dx
  end do

  ! Rescale position at level ilevel
  do idim=1,ndim
     do j=1,np
        x(j,idim)=xpart(j,idim)*one_over_scale+skip_loc(idim)
     end do
  end do
  do idim=1,ndim
     do j=1,np
        x(j,idim)=x(j,idim)-x0(idim)
     end do
  end do
  do idim=1,ndim
     do j=1,np
        x(j,idim)=x(j,idim)*one_over_dx
     end do
  end do

  ! NGP at level ilevel
  do idim=1,ndim
     do j=1,np
        id(j,idim)=int(x(j,idim))
     end do
  end do

   ! Compute parent grids
  do idim=1,ndim
     do j=1,np
        igd(j,idim)=id(j,idim)/2
     end do
  end do
#if NDIM==1
  do j=1,np
     kg(j)=1+igd(j,1)
  end do
#endif
#if NDIM==2
  do j=1,np
     kg(j)=1+igd(j,1)+3*igd(j,2)
  end do
#endif
#if NDIM==3
  do j=1,np
     kg(j)=1+igd(j,1)+3*igd(j,2)+9*igd(j,3)
  end do
#endif

  do j=1,np
     igrid(j)=son(nbors_father_cells(kg(j)))
  end do

  ! Check if particle has escaped to ilevel-1
  ok(1:np)=.true.
  do j=1,np
     if (igrid(j)==0)then
        ok(j)=.false.
        indp(j)=nbors_father_cells(kg(j))
        cell_lev(j)=ilevel-1
     end if
  end do
  
  ! Compute parent cell position
  do idim=1,ndim
     do j=1,np
           icd(j,idim)=id(j,idim)-2*igd(j,idim)
     end do
  end do
        
  call geticell99(icell,icd,np)
  
  ! Compute parent cell adress
  do j=1,np
     if(ok(j))then
        indp(j)=ncoarse+(icell(j)-1)*ngridmax+igrid(j)
     end if
  end do

  ! Check if particles have leaked into level ilevel+1
  do j=1,np
     if(ok(j))then
        if (son(indp(j))>0)then
           ok(j)=.false.
           cell_lev(j)=ilevel+1
           do idim=1,ndim
              icd_fine(1,idim)=int(2*(x(j,idim)-int(x(j,idim))))
           end do
           call geticell99(icell_fine,icd_fine,1)
           indp(j)=ncoarse+(icell_fine(1)-1)*ngridmax+son(indp(j))
        end if
     endif
  end do

  !cell center positions for particles which sit in the level ilevel
  do j=1,np
     if (ok(j))then
        cell_lev(j)=ilevel
     end if
  end do

end subroutine get_cell_index_fast
!################################################################
!################################################################
!################################################################
!################################################################
subroutine geticell99(icell,icd,np)
  use amr_parameters, only:ndim
  integer::np
  integer,dimension(1:99,1:ndim)::icd
  integer,dimension(1:99)::icell
  ! same as geticell but for input vector size of 99 instead of nvector
  integer::j
    
#if NDIM==1
  do j=1,np
     icell(j)=1+icd(j,1)
  end do
#endif
#if NDIM==2
  do j=1,np
     icell(j)=1+icd(j,1)+2*icd(j,2)
  end do
#endif
#if NDIM==3
  do j=1,np
     icell(j)=1+icd(j,1)+2*icd(j,2)+4*icd(j,3)
  end do
#endif
  
end subroutine geticell99
!##############################################################################
!##############################################################################
!##############################################################################
!##############################################################################
subroutine rho_only(ilevel)
  use amr_commons
  use pm_commons
  use hydro_commons
  use poisson_commons
  implicit none
#ifndef WITHOUTMPI
  include 'mpif.h'
#endif
  integer::ilevel
  !------------------------------------------------------------------
  ! This routine computes the density field at level ilevel using
  ! the CIC scheme. Particles that are not entirely in
  ! level ilevel contribute also to the level density field
  ! (boundary particles) using buffer grids.
  !------------------------------------------------------------------
  integer::iskip,icpu,ind,i,info,nx_loc,ibound,idim
  real(dp)::dx,scale,dx_loc

  if(.not. poisson)return
  if(numbtot(1,ilevel)==0)return
  if(verbose)write(*,111)ilevel

  ! Mesh spacing in that level
  dx=0.5D0**ilevel 
  nx_loc=icoarse_max-icoarse_min+1
  scale=boxlen/dble(nx_loc)
  dx_loc=dx*scale

  !-------------------------------------------------------
  ! Initialize rho to analytical and baryon density field
  !-------------------------------------------------------
  if(ilevel==levelmin)then
     do i=nlevelmax,ilevel,-1
        ! Compute mass multipole
        if(hydro)call multipole_fine(i)
        ! Perform TSC using pseudo-particle
#ifdef TSC
        if (ndim==3)then
           call tsc_from_multipole(i)
        else
           write(*,*)'TSC not supported for ndim neq 3'
           call clean_stop
        end if
#else
        ! Perform CIC using pseudo-particle
        call cic_from_multipole(i)
#endif
        ! Update boundaries
        call make_virtual_reverse_dp(rho(1),i)
        call make_virtual_fine_dp   (rho(1),i)
     end do
  end if

  !-------------------------------------------------------
  ! Initialize rho to zero in virtual boundaries
  !-------------------------------------------------------
  do icpu=1,ncpu
     do ind=1,twotondim
        iskip=ncoarse+(ind-1)*ngridmax
        do i=1,reception(icpu,ilevel)%ngrid
           rho(reception(icpu,ilevel)%igrid(i)+iskip)=0.0D0
        end do
     end do
  end do

  !---------------------------------------------------------
  ! Compute particle contribution to density field
  !---------------------------------------------------------
  ! Compute density due to current level particles
  if(pic)then
     call rho_only_level(ilevel)
  end if
  ! Update boudaries
  call make_virtual_reverse_dp(rho(1),ilevel)
  call make_virtual_fine_dp   (rho(1),ilevel)

  !----------------------------------------------------
  ! Reset rho in physical boundaries
  !----------------------------------------------------
  do ibound=1,nboundary
     do ind=1,twotondim
        iskip=ncoarse+(ind-1)*ngridmax
        do i=1,boundary(ibound,ilevel)%ngrid
           rho(boundary(ibound,ilevel)%igrid(i)+iskip)=0.0
        end do
     end do
  end do

111 format('   Entering rho_only for level ',I2)
  
end subroutine rho_only
!##############################################################################
!##############################################################################
!##############################################################################
!##############################################################################
subroutine rho_only_level(ilevel)
  use amr_commons
  use pm_commons
  use hydro_commons
  use poisson_commons
  use clfind_commons
  implicit none
  integer::ilevel
  !------------------------------------------------------------------
  ! This routine computes the density field at level ilevel using
  ! the CIC scheme from particles that are not entirely in
  ! level ilevel (boundary particles).
  ! Arrays flag1 and flag2 are used as temporary work space.
  !------------------------------------------------------------------
  integer::igrid,jgrid,ipart,jpart,idim,icpu,next_part
  integer::i,ig,ip,npart1,npart2
  real(dp)::dx

  integer,dimension(1:nvector),save::ind_grid,ind_cell
  integer,dimension(1:nvector),save::ind_part,ind_grid_part
  real(dp),dimension(1:nvector,1:ndim),save::x0

  ! Mesh spacing in that level
  dx=0.5D0**ilevel

  ! Loop over cpus
  do icpu=1,ncpu
     ! Loop over grids
     igrid=headl(icpu,ilevel)
     ig=0
     ip=0   
     do jgrid=1,numbl(icpu,ilevel)
        npart1=numbp(igrid)  ! Number of particles in the grid
        npart2=0

        ! Count elligible particles
        if(npart1>0)then
           ipart=headp(igrid)
           ! Loop over particles
           do jpart=1,npart1
              ! Save next particle   <--- Very important !!!
              next_part=nextp(ipart)
              ! Select stars younger than age_cut_clfind
              if(age_cut_clfind>0.d0 .and. star) then
                 if((t-tp(ipart).lt.age_cut_clfind).and.(tp(ipart).ne.0.d0)) then
                    npart2=npart2+1
                 endif
              ! All particles
              else
                 npart2=npart2+1
              endif
              ipart=next_part  ! Go to next particle
           end do
        endif

        ! Gather elligible particles
        if(npart2>0)then        
           ig=ig+1
           ind_grid(ig)=igrid
           ipart=headp(igrid)
           
           ! Loop over particles
           do jpart=1,npart1
              ! Save next particle   <--- Very important !!!
              next_part=nextp(ipart)
              ! Select stars younger than age_cut_clfind
              if(age_cut_clfind>0.d0 .and. star) then
                 if((t-tp(ipart).lt.age_cut_clfind).and.(tp(ipart).ne.0.d0)) then
                    if(ig==0)then
                       ig=1
                       ind_grid(ig)=igrid
                    end if
                    ip=ip+1
                    ind_part(ip)=ipart
                    ind_grid_part(ip)=ig
                 endif
              ! All particles
              else
                 if(ig==0)then
                    ig=1
                    ind_grid(ig)=igrid
                 end if
                 ip=ip+1
                 ind_part(ip)=ipart
                 ind_grid_part(ip)=ig
              endif
              if(ip==nvector)then
                 ! Lower left corner of 3x3x3 grid-cube
                 do idim=1,ndim
                    do i=1,ig
                       x0(i,idim)=xg(ind_grid(i),idim)-3.0D0*dx
                    end do
                 end do
                 do i=1,ig
                    ind_cell(i)=father(ind_grid(i))
                 end do
#ifdef TSC
                 call tsc_only(ind_cell,ind_part,ind_grid_part,x0,ig,ip,ilevel)
#else
                 call cic_only(ind_cell,ind_part,ind_grid_part,x0,ig,ip,ilevel)
#endif

                 ip=0
                 ig=0
              end if
              ipart=next_part  ! Go to next particle
           end do
           ! End loop over particles
           
        end if

        igrid=next(igrid)   ! Go to next grid
     end do
     ! End loop over grids

     if(ip>0)then
        ! Lower left corner of 3x3x3 grid-cube
        do idim=1,ndim
           do i=1,ig
              x0(i,idim)=xg(ind_grid(i),idim)-3.0D0*dx
           end do
        end do
        do i=1,ig
           ind_cell(i)=father(ind_grid(i))
        end do
#ifdef TSC
        call tsc_only(ind_cell,ind_part,ind_grid_part,x0,ig,ip,ilevel)
#else
        call cic_only(ind_cell,ind_part,ind_grid_part,x0,ig,ip,ilevel)
#endif
     end if

  end do
  ! End loop over cpus

end subroutine rho_only_level
!##############################################################################
!##############################################################################
!##############################################################################
!##############################################################################
subroutine cic_only(ind_cell,ind_part,ind_grid_part,x0,ng,np,ilevel)
  use amr_commons
  use pm_commons
  use poisson_commons
  implicit none
  integer::ng,np,ilevel
  integer ,dimension(1:nvector)::ind_cell,ind_grid_part,ind_part
  real(dp),dimension(1:nvector,1:ndim)::x0
  !------------------------------------------------------------------
  ! This routine computes the density field at level ilevel using
  ! the CIC scheme. Only cells that are in level ilevel
  ! are updated by the input particle list.
  !------------------------------------------------------------------
  logical::error
  integer::j,ind,idim,nx_loc
  real(dp)::dx,dx_loc,scale,vol_loc
  ! Grid-based arrays
  integer ,dimension(1:nvector,1:threetondim),save::nbors_father_cells
  integer ,dimension(1:nvector,1:twotondim),save::nbors_father_grids
  ! Particle-based arrays
  logical ,dimension(1:nvector),save::ok
  real(dp),dimension(1:nvector),save::mmm
  real(dp),dimension(1:nvector),save::vol2
  real(dp),dimension(1:nvector,1:ndim),save::x,dd,dg
  integer ,dimension(1:nvector,1:ndim),save::ig,id,igg,igd,icg,icd
  real(dp),dimension(1:nvector,1:twotondim),save::vol
  integer ,dimension(1:nvector,1:twotondim),save::igrid,icell,indp,kg
  real(dp),dimension(1:3)::skip_loc

  ! Mesh spacing in that level
  dx=0.5D0**ilevel
  nx_loc=(icoarse_max-icoarse_min+1)
  skip_loc=(/0.0d0,0.0d0,0.0d0/)
  if(ndim>0)skip_loc(1)=dble(icoarse_min)
  if(ndim>1)skip_loc(2)=dble(jcoarse_min)
  if(ndim>2)skip_loc(3)=dble(kcoarse_min)
  scale=boxlen/dble(nx_loc)
  dx_loc=dx*scale
  vol_loc=dx_loc**ndim

  ! Gather neighboring father cells (should be present anytime !)
  call get3cubefather(ind_cell,nbors_father_cells,nbors_father_grids,ng,ilevel)

  ! Rescale particle position at level ilevel
  do idim=1,ndim
     do j=1,np
        x(j,idim)=xp(ind_part(j),idim)/scale+skip_loc(idim)
     end do
  end do
  do idim=1,ndim
     do j=1,np
        x(j,idim)=x(j,idim)-x0(ind_grid_part(j),idim)
     end do
  end do
  do idim=1,ndim
     do j=1,np
        x(j,idim)=x(j,idim)/dx
     end do
  end do

  ! Gather particle mass
  do j=1,np
     mmm(j)=mp(ind_part(j))
  end do

  ! Check for illegal moves
  error=.false.
  do idim=1,ndim
     do j=1,np
        if(x(j,idim)<0.5D0.or.x(j,idim)>5.5D0)error=.true.
     end do
  end do
  if(error)then
     write(*,*)'problem in cic_only'
     do idim=1,ndim
        do j=1,np
           if(x(j,idim)<0.5D0.or.x(j,idim)>5.5D0)then
              write(*,*)x(j,1:ndim)
           endif
        end do
     end do
     stop
  end if

  ! CIC at level ilevel (dd: right cloud boundary; dg: left cloud boundary)
  do idim=1,ndim
     do j=1,np
        dd(j,idim)=x(j,idim)+0.5D0
        id(j,idim)=dd(j,idim)
        dd(j,idim)=dd(j,idim)-id(j,idim)
        dg(j,idim)=1.0D0-dd(j,idim)
        ig(j,idim)=id(j,idim)-1
     end do
  end do

  ! Compute cloud volumes
#if NDIM==1
  do j=1,np
     vol(j,1)=dg(j,1)
     vol(j,2)=dd(j,1)
  end do
#endif
#if NDIM==2
  do j=1,np
     vol(j,1)=dg(j,1)*dg(j,2)
     vol(j,2)=dd(j,1)*dg(j,2)
     vol(j,3)=dg(j,1)*dd(j,2)
     vol(j,4)=dd(j,1)*dd(j,2)
  end do
#endif
#if NDIM==3
  do j=1,np
     vol(j,1)=dg(j,1)*dg(j,2)*dg(j,3)
     vol(j,2)=dd(j,1)*dg(j,2)*dg(j,3)
     vol(j,3)=dg(j,1)*dd(j,2)*dg(j,3)
     vol(j,4)=dd(j,1)*dd(j,2)*dg(j,3)
     vol(j,5)=dg(j,1)*dg(j,2)*dd(j,3)
     vol(j,6)=dd(j,1)*dg(j,2)*dd(j,3)
     vol(j,7)=dg(j,1)*dd(j,2)*dd(j,3)
     vol(j,8)=dd(j,1)*dd(j,2)*dd(j,3)
  end do
#endif

  ! Compute parent grids
  do idim=1,ndim
     do j=1,np
        igg(j,idim)=ig(j,idim)/2
        igd(j,idim)=id(j,idim)/2
     end do
  end do
#if NDIM==1
  do j=1,np
     kg(j,1)=1+igg(j,1)
     kg(j,2)=1+igd(j,1)
  end do
#endif
#if NDIM==2
  do j=1,np
     kg(j,1)=1+igg(j,1)+3*igg(j,2)
     kg(j,2)=1+igd(j,1)+3*igg(j,2)
     kg(j,3)=1+igg(j,1)+3*igd(j,2)
     kg(j,4)=1+igd(j,1)+3*igd(j,2)
  end do
#endif
#if NDIM==3
  do j=1,np
     kg(j,1)=1+igg(j,1)+3*igg(j,2)+9*igg(j,3)
     kg(j,2)=1+igd(j,1)+3*igg(j,2)+9*igg(j,3)
     kg(j,3)=1+igg(j,1)+3*igd(j,2)+9*igg(j,3)
     kg(j,4)=1+igd(j,1)+3*igd(j,2)+9*igg(j,3)
     kg(j,5)=1+igg(j,1)+3*igg(j,2)+9*igd(j,3)
     kg(j,6)=1+igd(j,1)+3*igg(j,2)+9*igd(j,3)
     kg(j,7)=1+igg(j,1)+3*igd(j,2)+9*igd(j,3)
     kg(j,8)=1+igd(j,1)+3*igd(j,2)+9*igd(j,3)
  end do
#endif
  do ind=1,twotondim
     do j=1,np
        igrid(j,ind)=son(nbors_father_cells(ind_grid_part(j),kg(j,ind)))
     end do
  end do

  ! Compute parent cell position
  do idim=1,ndim
     do j=1,np
        icg(j,idim)=ig(j,idim)-2*igg(j,idim)
        icd(j,idim)=id(j,idim)-2*igd(j,idim)
     end do
  end do
#if NDIM==1
  do j=1,np
     icell(j,1)=1+icg(j,1)
     icell(j,2)=1+icd(j,1)
  end do
#endif
#if NDIM==2
  do j=1,np
     icell(j,1)=1+icg(j,1)+2*icg(j,2)
     icell(j,2)=1+icd(j,1)+2*icg(j,2)
     icell(j,3)=1+icg(j,1)+2*icd(j,2)
     icell(j,4)=1+icd(j,1)+2*icd(j,2)
  end do
#endif
#if NDIM==3
  do j=1,np
     icell(j,1)=1+icg(j,1)+2*icg(j,2)+4*icg(j,3)
     icell(j,2)=1+icd(j,1)+2*icg(j,2)+4*icg(j,3)
     icell(j,3)=1+icg(j,1)+2*icd(j,2)+4*icg(j,3)
     icell(j,4)=1+icd(j,1)+2*icd(j,2)+4*icg(j,3)
     icell(j,5)=1+icg(j,1)+2*icg(j,2)+4*icd(j,3)
     icell(j,6)=1+icd(j,1)+2*icg(j,2)+4*icd(j,3)
     icell(j,7)=1+icg(j,1)+2*icd(j,2)+4*icd(j,3)
     icell(j,8)=1+icd(j,1)+2*icd(j,2)+4*icd(j,3)
  end do
#endif

  ! Compute parent cell adress
  do ind=1,twotondim
     do j=1,np
        indp(j,ind)=ncoarse+(icell(j,ind)-1)*ngridmax+igrid(j,ind)
     end do
  end do

  ! Update mass density field
  do ind=1,twotondim
     do j=1,np
        ok(j)=igrid(j,ind)>0
     end do
     do j=1,np
        vol2(j)=mmm(j)*vol(j,ind)/vol_loc
     end do
     do j=1,np
        if(ok(j))then
           rho(indp(j,ind))=rho(indp(j,ind))+vol2(j)
        end if
     end do
  end do

end subroutine cic_only
!##############################################################################
!##############################################################################
!##############################################################################
!##############################################################################
subroutine tsc_only(ind_cell,ind_part,ind_grid_part,x0,ng,np,ilevel)
  use amr_commons
  use pm_commons
  use poisson_commons
  implicit none
  integer::ng,np,ilevel
  integer ,dimension(1:nvector)::ind_cell,ind_grid_part,ind_part
  real(dp),dimension(1:nvector,1:ndim)::x0
  !------------------------------------------------------------------
  ! This routine computes the density field at level ilevel using
  ! the TSC scheme. Only cells that are in level ilevel
  ! are updated by the input particle list.
  !------------------------------------------------------------------
  integer::j,ind,idim,nx_loc
  real(dp)::dx,dx_loc,scale,vol_loc
  ! Grid-based arrays
  integer ,dimension(1:nvector,1:threetondim),save::nbors_father_cells
  integer ,dimension(1:nvector,1:twotondim),save::nbors_father_grids
  ! Particle-based arrays
  logical ,dimension(1:nvector),save::ok,abandoned
  real(dp),dimension(1:nvector),save::mmm
  real(dp),dimension(1:nvector),save::ttt=0d0
  real(dp),dimension(1:nvector),save::vol2
  real(dp),dimension(1:nvector,1:ndim),save::x,cl,cr,cc,wl,wr,wc
  integer ,dimension(1:nvector,1:ndim),save::igl,igr,igc,icl,icr,icc
  real(dp),dimension(1:nvector,1:threetondim),save::vol
  integer ,dimension(1:nvector,1:threetondim),save::igrid,icell,indp,kg
  real(dp),dimension(1:3)::skip_loc

  if (ndim .ne. 3)then
     write(*,*)'TSC not supported for ndim neq 3'
     call clean_stop
  end if

#if NDIM==3

  ! Mesh spacing in that level
  dx=0.5D0**ilevel
  nx_loc=(icoarse_max-icoarse_min+1)
  skip_loc=(/0.0d0,0.0d0,0.0d0/)
  if(ndim>0)skip_loc(1)=dble(icoarse_min)
  if(ndim>1)skip_loc(2)=dble(jcoarse_min)
  if(ndim>2)skip_loc(3)=dble(kcoarse_min)
  scale=boxlen/dble(nx_loc)
  dx_loc=dx*scale
  vol_loc=dx_loc**ndim

  ! Gather neighboring father cells (should be present at anytime!)
  call get3cubefather(ind_cell,nbors_father_cells,nbors_father_grids,ng,ilevel)

  ! Rescale particle position at level ilevel
  do idim=1,ndim
     do j=1,np
        x(j,idim)=xp(ind_part(j),idim)/scale+skip_loc(idim)
     end do
  end do
  do idim=1,ndim
     do j=1,np
        x(j,idim)=x(j,idim)-x0(ind_grid_part(j),idim)
     end do
  end do
  do idim=1,ndim
     do j=1,np
        x(j,idim)=x(j,idim)/dx
     end do
  end do

  ! Gather particle mass
  do j=1,np
     mmm(j)=mp(ind_part(j))
  end do

  ! Check for illegal moves
  abandoned(1:np)=.false.
  do idim=1,ndim
     do j=1,np
        if(x(j,idim)<1.0D0.or.x(j,idim)>5.0D0) abandoned(j)=.true.
     end do
  end do

  ! TSC at level ilevel; a particle contributes
  !     to three cells in each dimension
  ! cl: position of leftmost cell centre
  ! cc: position of central cell centre
  ! cr: position of rightmost cell centre
  ! wl: weighting function for leftmost cell
  ! wc: weighting function for central cell
  ! wr: weighting function for rightmost cell
  do idim=1,ndim
     do j=1,np
        if(.not.abandoned(j)) then
           cl(j,idim)=dble(int(x(j,idim)))-0.5D0
           cc(j,idim)=dble(int(x(j,idim)))+0.5D0
           cr(j,idim)=dble(int(x(j,idim)))+1.5D0
           wl(j,idim)=0.50D0*(1.5D0-abs(x(j,idim)-cl(j,idim)))**2
           wc(j,idim)=0.75D0-          (x(j,idim)-cc(j,idim)) **2
           wr(j,idim)=0.50D0*(1.5D0-abs(x(j,idim)-cr(j,idim)))**2
        end if
     end do
  end do

  ! Compute cloud volumes
  do j=1,np
     if(.not.abandoned(j)) then
        vol(j,1 )=wl(j,1)*wl(j,2)*wl(j,3)
        vol(j,2 )=wc(j,1)*wl(j,2)*wl(j,3)
        vol(j,3 )=wr(j,1)*wl(j,2)*wl(j,3)
        vol(j,4 )=wl(j,1)*wc(j,2)*wl(j,3)
        vol(j,5 )=wc(j,1)*wc(j,2)*wl(j,3)
        vol(j,6 )=wr(j,1)*wc(j,2)*wl(j,3)
        vol(j,7 )=wl(j,1)*wr(j,2)*wl(j,3)
        vol(j,8 )=wc(j,1)*wr(j,2)*wl(j,3)
        vol(j,9 )=wr(j,1)*wr(j,2)*wl(j,3)
        vol(j,10)=wl(j,1)*wl(j,2)*wc(j,3)
        vol(j,11)=wc(j,1)*wl(j,2)*wc(j,3)
        vol(j,12)=wr(j,1)*wl(j,2)*wc(j,3)
        vol(j,13)=wl(j,1)*wc(j,2)*wc(j,3)
        vol(j,14)=wc(j,1)*wc(j,2)*wc(j,3)
        vol(j,15)=wr(j,1)*wc(j,2)*wc(j,3)
        vol(j,16)=wl(j,1)*wr(j,2)*wc(j,3)
        vol(j,17)=wc(j,1)*wr(j,2)*wc(j,3)
        vol(j,18)=wr(j,1)*wr(j,2)*wc(j,3)
        vol(j,19)=wl(j,1)*wl(j,2)*wr(j,3)
        vol(j,20)=wc(j,1)*wl(j,2)*wr(j,3)
        vol(j,21)=wr(j,1)*wl(j,2)*wr(j,3)
        vol(j,22)=wl(j,1)*wc(j,2)*wr(j,3)
        vol(j,23)=wc(j,1)*wc(j,2)*wr(j,3)
        vol(j,24)=wr(j,1)*wc(j,2)*wr(j,3)
        vol(j,25)=wl(j,1)*wr(j,2)*wr(j,3)
        vol(j,26)=wc(j,1)*wr(j,2)*wr(j,3)
        vol(j,27)=wr(j,1)*wr(j,2)*wr(j,3)
     end if
  end do

  ! Compute parent grids
  do idim=1,ndim
     do j=1,np
        if(.not.abandoned(j)) then
           igl(j,idim)=(int(cl(j,idim)))/2
           igc(j,idim)=(int(cc(j,idim)))/2
           igr(j,idim)=(int(cr(j,idim)))/2
        end if
     end do
  end do
  do j=1,np
     if(.not.abandoned(j)) then
        kg(j,1 )=1+igl(j,1)+3*igl(j,2)+9*igl(j,3)
        kg(j,2 )=1+igc(j,1)+3*igl(j,2)+9*igl(j,3)
        kg(j,3 )=1+igr(j,1)+3*igl(j,2)+9*igl(j,3)
        kg(j,4 )=1+igl(j,1)+3*igc(j,2)+9*igl(j,3)
        kg(j,5 )=1+igc(j,1)+3*igc(j,2)+9*igl(j,3)
        kg(j,6 )=1+igr(j,1)+3*igc(j,2)+9*igl(j,3)
        kg(j,7 )=1+igl(j,1)+3*igr(j,2)+9*igl(j,3)
        kg(j,8 )=1+igc(j,1)+3*igr(j,2)+9*igl(j,3)
        kg(j,9 )=1+igr(j,1)+3*igr(j,2)+9*igl(j,3)
        kg(j,10)=1+igl(j,1)+3*igl(j,2)+9*igc(j,3)
        kg(j,11)=1+igc(j,1)+3*igl(j,2)+9*igc(j,3)
        kg(j,12)=1+igr(j,1)+3*igl(j,2)+9*igc(j,3)
        kg(j,13)=1+igl(j,1)+3*igc(j,2)+9*igc(j,3)
        kg(j,14)=1+igc(j,1)+3*igc(j,2)+9*igc(j,3)
        kg(j,15)=1+igr(j,1)+3*igc(j,2)+9*igc(j,3)
        kg(j,16)=1+igl(j,1)+3*igr(j,2)+9*igc(j,3)
        kg(j,17)=1+igc(j,1)+3*igr(j,2)+9*igc(j,3)
        kg(j,18)=1+igr(j,1)+3*igr(j,2)+9*igc(j,3)
        kg(j,19)=1+igl(j,1)+3*igl(j,2)+9*igr(j,3)
        kg(j,20)=1+igc(j,1)+3*igl(j,2)+9*igr(j,3)
        kg(j,21)=1+igr(j,1)+3*igl(j,2)+9*igr(j,3)
        kg(j,22)=1+igl(j,1)+3*igc(j,2)+9*igr(j,3)
        kg(j,23)=1+igc(j,1)+3*igc(j,2)+9*igr(j,3)
        kg(j,24)=1+igr(j,1)+3*igc(j,2)+9*igr(j,3)
        kg(j,25)=1+igl(j,1)+3*igr(j,2)+9*igr(j,3)
        kg(j,26)=1+igc(j,1)+3*igr(j,2)+9*igr(j,3)
        kg(j,27)=1+igr(j,1)+3*igr(j,2)+9*igr(j,3)
     end if
  end do
  do ind=1,threetondim
     do j=1,np
        igrid(j,ind)=son(nbors_father_cells(ind_grid_part(j),kg(j,ind)))
     end do
  end do

  ! Compute parent cell position
  do idim=1,ndim
     do j=1,np
        if(.not.abandoned(j)) then
           icl(j,idim)=int(cl(j,idim))-2*igl(j,idim)
           icc(j,idim)=int(cc(j,idim))-2*igc(j,idim)
           icr(j,idim)=int(cr(j,idim))-2*igr(j,idim)
        end if
     end do
  end do
  do j=1,np
     if(.not.abandoned(j)) then
        icell(j,1 )=1+icl(j,1)+2*icl(j,2)+4*icl(j,3)
        icell(j,2 )=1+icc(j,1)+2*icl(j,2)+4*icl(j,3)
        icell(j,3 )=1+icr(j,1)+2*icl(j,2)+4*icl(j,3)
        icell(j,4 )=1+icl(j,1)+2*icc(j,2)+4*icl(j,3)
        icell(j,5 )=1+icc(j,1)+2*icc(j,2)+4*icl(j,3)
        icell(j,6 )=1+icr(j,1)+2*icc(j,2)+4*icl(j,3)
        icell(j,7 )=1+icl(j,1)+2*icr(j,2)+4*icl(j,3)
        icell(j,8 )=1+icc(j,1)+2*icr(j,2)+4*icl(j,3)
        icell(j,9 )=1+icr(j,1)+2*icr(j,2)+4*icl(j,3)
        icell(j,10)=1+icl(j,1)+2*icl(j,2)+4*icc(j,3)
        icell(j,11)=1+icc(j,1)+2*icl(j,2)+4*icc(j,3)
        icell(j,12)=1+icr(j,1)+2*icl(j,2)+4*icc(j,3)
        icell(j,13)=1+icl(j,1)+2*icc(j,2)+4*icc(j,3)
        icell(j,14)=1+icc(j,1)+2*icc(j,2)+4*icc(j,3)
        icell(j,15)=1+icr(j,1)+2*icc(j,2)+4*icc(j,3)
        icell(j,16)=1+icl(j,1)+2*icr(j,2)+4*icc(j,3)
        icell(j,17)=1+icc(j,1)+2*icr(j,2)+4*icc(j,3)
        icell(j,18)=1+icr(j,1)+2*icr(j,2)+4*icc(j,3)
        icell(j,19)=1+icl(j,1)+2*icl(j,2)+4*icr(j,3)
        icell(j,20)=1+icc(j,1)+2*icl(j,2)+4*icr(j,3)
        icell(j,21)=1+icr(j,1)+2*icl(j,2)+4*icr(j,3)
        icell(j,22)=1+icl(j,1)+2*icc(j,2)+4*icr(j,3)
        icell(j,23)=1+icc(j,1)+2*icc(j,2)+4*icr(j,3)
        icell(j,24)=1+icr(j,1)+2*icc(j,2)+4*icr(j,3)
        icell(j,25)=1+icl(j,1)+2*icr(j,2)+4*icr(j,3)
        icell(j,26)=1+icc(j,1)+2*icr(j,2)+4*icr(j,3)
        icell(j,27)=1+icr(j,1)+2*icr(j,2)+4*icr(j,3)
     end if
  end do

  ! Compute parent cell adress
  do ind=1,threetondim
     do j=1,np
        if(.not.abandoned(j)) then
           indp(j,ind)=ncoarse+(icell(j,ind)-1)*ngridmax+igrid(j,ind)
        end if
     end do
  end do

  ! Update mass density and number density fields
  do ind=1,threetondim

     do j=1,np
        if(.not.abandoned(j)) then
           ok(j)=igrid(j,ind)>0
        end if
     end do

     do j=1,np
        if(.not.abandoned(j)) then
           vol2(j)=mmm(j)*vol(j,ind)/vol_loc
        end if
     end do

     do j=1,np
        if(ok(j).and.(.not.abandoned(j))) then
           rho(indp(j,ind))=rho(indp(j,ind))+vol2(j)
        end if
     end do

  end do
#endif
end subroutine tsc_only
!###########################################################
!###########################################################
!###########################################################
!###########################################################

../patch/collapse/condinit.f90
!================================================================
!================================================================
!================================================================
!================================================================
subroutine condinit(x,u,dx,nn)
  use amr_commons
  use hydro_commons
  use poisson_parameters
  use radiation_parameters
  use cooling_module,ONLY:kB,mH  
  use units_commons
  use cloud_module
  
  implicit none

  integer ::nn                              ! Number of cells
  real(dp)::dx                              ! Cell size
  real(dp),dimension(1:nvector,1:nvar+3)::u ! Conservative variables
  real(dp),dimension(1:nvector,1:ndim)::x   ! Cell center position.
  !================================================================
  ! This routine generates initial conditions for RAMSES.
  ! Positions are in user units:
  ! x(i,1:3) are in [0,boxlen]**ndim.
  ! U is the conservative variable vector. Conventions are here:
  ! U(i,1): d, U(i,2:4): d.u,d.v,d.w, U(i,5): E, U(i,6:8): Bleft, 
  ! U(i,nvar+1:nvar+3): Bright
  ! Q is the primitive variable vector. Conventions are here:
  ! Q(i,1): d, Q(i,2:4):u,v,w, Q(i,5): P, Q(i,6:8): Bleft, 
  ! Q(i,nvar+1:nvar+3): Bright
  ! If nvar > 8, remaining variables (9:nvar) are treated as passive
  ! scalars in the hydro solver.
  ! U(:,:) and Q(:,:) are in user units.
  !================================================================
  integer::ivar
  real(dp),dimension(1:nvector,1:nvar+3),save::q   ! Primitive variables

  integer :: i,j,k,id,iu,iv,iw,ip,igroup
  real(dp):: x0,y0,z0,rc,rs,xx,yy,zz,pi,r0,d0,B0,p0,omega0,radiation_source,mass
  integer :: np
  real(dp)::Temp
  
  logical,save:: first=.true.
  real(dp),dimension(1:3,1:100,1:100,1:100),save::q_idl
  real(dp),save::vx_tot,vy_tot,vz_tot,vx2_tot,vy2_tot,vz2_tot
  integer,save:: n_size
  integer:: ind_i, ind_j, ind_k
  real(dp),save:: d_c,B_c,ind,seed1,seed2,seed3,xi,yi,zi,zeta
  real(dp),save:: res_int,r_0,C_s,omega,v_rms,cont_ic,mass_total,mass_tot2,min_col_d,max_col_d
  real(dp):: col_d,eli,sph,vx,vy,vz
  real(dp)::xl,yl,zl,bx,by,bz,dxmin
  integer:: ii,jj,kk,nticks
  integer, save :: count_vrms
  real(dp)::ener_rot,ener_grav,ener_therm,ener_grav2,ener_turb,dd,ee,theta_mag_radians
  real(dp),dimension(1000):: mass_rad    
  real(dp),dimension(1:3,1:3):: rot_M,rot_invM,rot_tilde

  real(dp) :: sum_dust
#if NDUST>0
  integer :: idust,idust_pscal
  real(dp):: epsilon_0
  real(dp),dimension(1:ndust):: dustMRN
  real(dp), dimension(1:ndust) ::d_grain,l_grain
  epsilon_0 = dust_ratio(1)
#endif
  small_er=eray_min/(scale_d*scale_v**2)

  q(1:nvector,1:nvar+3) = 0.0d0
  
  id=1; iu=2; iv=3; iw=4; ip=5
  x0=0.5*boxlen
  y0=0.5*boxlen
  z0=0.5*boxlen
  pi=acos(-1.0d0)
  theta_mag_radians = theta_mag/180.0d0*pi


  if(bb_test)then
     sum_dust=0.0d0
#if NDUST>0
     do idust =1,ndust
        dustMRN(idust) = dust_ratio(idust)/(1.0d0+dust_ratio(idust))
     end do
     if(mrn) call init_dust_ratio(epsilon_0, dustMRN)
     do idust =1,ndust
        sum_dust = sum_dust + dustMRN(idust)
     end do
     if(mrn.eqv..true.) then
        call size_dust(l_grain)
        do idust=1,ndust
           l_grain(idust) = l_grain(idust)/scale_l
           d_grain(idust)=  grain_dens(idust)/scale_d
        end do
     else
        do idust=1,ndust
           d_grain(idust)=grain_dens(idust)/scale_d
           l_grain(idust)=grain_size(idust)/scale_l
           
        end do
     endif
#endif     
         
     ! cloud radius equal to unity
     r0=(alpha_dense_core*2.*6.67d-8*mass_c*scale_m*mu_gas*mH/(5.*kB*Tr_floor*(1.0d0-sum_dust)))/scale_l
     ! cloud density equal to unity
     d0 = 3.0d0*mass_c/(4.0d0*pi*r0**3.)
     ! threshold for ambipolar fluxes
     !rho_threshold = d0/10.d0
     ! cloud rotation
     omega0 = sqrt(beta_dense_core*4.*pi*d0)

     rot_M(1,1:3) = (/cos(theta_mag_radians),0.0d0,-sin(theta_mag_radians)/)
     rot_M(2,1:3) = (/0.0d0,1.0d0,0.0d0/)
     rot_M(3,1:3) = (/sin(theta_mag_radians),0.0d0,cos(theta_mag_radians)/)

     rot_invM(1,1:3) = (/cos(theta_mag_radians),0.0d0,sin(theta_mag_radians)/)
     rot_invM(2,1:3) = (/0.0d0,1.0d0,0.0d0/)
     rot_invM(3,1:3) = (/-sin(theta_mag_radians),0.0d0,cos(theta_mag_radians)/)


     rot_tilde(1,1:3) = (/0.0d0,1.0d0,0.0d0/)
     rot_tilde(2,1:3) = (/-1.0d0,0.0d0,0.0d0/)
     rot_tilde(3,1:3) = (/0.0d0,0.0d0,0.0d0/)

     ! sound speed
     Temp = Tr_floor
     C_s = sqrt( Temp / scale_T2 )

     ! turbulence
     if( first) then 
        vx_tot=0.d0
        vy_tot=0.d0
        vz_tot=0.d0
        vx2_tot=0.d0
        vy2_tot=0.d0
        vz2_tot=0.d0
        v_rms=0.d0 
        count_vrms=0
        if(Mach .ne. 0)then
           if (myid==1) write(*,*) 'Read the file which contains the initial turbulent velocity field'
           open(20,file='init_turb.data',form='formatted')
           read(20,*) n_size, ind, seed1,seed2,seed3
           if(n_size .ne. 100) then
              write(*,*) 'Unextected field size'
              stop
           endif
           do k=1,n_size
              do j=1,n_size
                 do i=1,n_size
                    read(20,*)xi,yi,zi,vx,vy,vz
                    q_idl(1,i,j,k) = vx
                    q_idl(2,i,j,k) = vy
                    q_idl(3,i,j,k) = vz
                    xi = boxlen*((i-0.5)/n_size)-x0
                    yi = boxlen*((j-0.5)/n_size)-y0
                    zi = boxlen*((k-0.5)/n_size)-z0
                    rs=sqrt(xi**2+yi**2+zi**2)

                    IF(rs .le. r0) THEN 
                       !                    print*, vx_tot,vy_tot,vz_tot,vx2_tot,vy2_tot,vz2_tot
                       vx_tot = vx_tot + vx
                       vy_tot = vy_tot + vy
                       vz_tot = vz_tot + vz

                       vx2_tot = vx2_tot + vx**2
                       vy2_tot = vy2_tot + vy**2
                       vz2_tot = vz2_tot + vz**2

                       count_vrms=count_vrms+1
                    end if
                 end do
              end do
           end do
           close(20)
           v_rms=sqrt((vx2_tot+vy2_tot+vz2_tot)/dble(count_vrms)-((vx_tot+vy_tot+vz_tot)/dble(count_vrms))**2)
           if (myid == 1) print *, 'v_rms for given seed =',v_rms
           ! correction factor to have the expected Mach number stored in v_rms
           v_rms = Mach*C_s/v_rms
           if (myid == 1) print *, 'correction factor for turbulent field =',v_rms
        end if

        if(myid==1)then
           print*,'alpha_dense_core=',alpha_dense_core
           print*,'beta_dense_core=',beta_dense_core
           print*,'Mass=',mass_c*scale_m/Msun,' Msun'
           print*,'d0=',d0*scale_d
           print*,'Turbulent Mach=',Mach
           print*,r0,boxlen
        endif
        first = .false.
     end if

     ! vertical magnetic field
     B0 = sqrt(4.*pi/5.)/0.53*(crit*d0*r0) ! Remember G=1 in code units

     DO i=1,nn
        xx=x(i,1)-x0
        yy=x(i,2)-y0
        zz=x(i,3)-z0

        q(i,iu) = 0.0d0
        q(i,iv) = 0.0d0
        q(i,iw) = 0.0d0

        if(Mach .ne. 0)then
           !initialise the turbulent velocity field
           !make a zero order interpolation (should be improved)
           ind_i = int((x(i,1)/boxlen)*n_size)+1
           ind_j = int((x(i,2)/boxlen)*n_size)+1
           ind_k = int((x(i,3)/boxlen)*n_size)+1
           ! safe check
           if( ind_i .lt. 1 .or. ind_i .gt. n_size) write(*,*) 'ind_i ',ind_i,(x(i,1)/boxlen)*n_size+1,n_size
           if( ind_j .lt. 1 .or. ind_j .gt. n_size) write(*,*) 'ind_j ',ind_j
           if( ind_k .lt. 1 .or. ind_k .gt. n_size) write(*,*) 'ind_k ',ind_k
        end if

        rc=sqrt(xx**2+yy**2)
        rs=sqrt(xx**2+yy**2+zz**2)

        IF(rs .le. r0) THEN 

           q(i,id) = d0*(1.0+delta_rho*cos(2.*atan(yy/(cos(theta_mag_radians)*xx-sin(theta_mag_radians)*zz))))
           if(Mach .ne. 0)then
              q(i,iu) =  v_rms*(q_idl(1,ind_i,ind_j,ind_k)-vx_tot/dble(count_vrms))
              q(i,iv) =  v_rms*(q_idl(2,ind_i,ind_j,ind_k)-vy_tot/dble(count_vrms))
              q(i,iw) =  v_rms*(q_idl(3,ind_i,ind_j,ind_k)-vz_tot/dble(count_vrms))
           end if
           q(i,iu:iw) = q(i,iu:iw)+matmul(rot_invM,omega0*matmul(rot_tilde,matmul(rot_M,(/xx,yy,zz/))))

#if NGRP>0
           do igroup=1,ngrp
              q(i,firstindex_er+igroup) = radiation_source(Temp,igroup)/(scale_d*scale_v**2)
           enddo
#endif
        ELSE
           q(i,id) = d0/contrast
           xx = r0 * xx / rc
           yy = r0 * yy / rc
           if(Mach .ne. 0)then
              q(i,iu) = v_rms*(q_idl(1,ind_i,ind_j,ind_k)-vx_tot/dble(count_vrms))! omega0 * yy
              q(i,iv) = v_rms*(q_idl(2,ind_i,ind_j,ind_k)-vy_tot/dble(count_vrms))!-omega0 * xx
              q(i,iw) = v_rms*(q_idl(3,ind_i,ind_j,ind_k)-vz_tot/dble(count_vrms))
           end if

#if NGRP>0
           do igroup=1,ngrp
              q(i,firstindex_er+igroup) = radiation_source(Temp,igroup)/(scale_d*scale_v**2)
           enddo
#endif
        ENDIF

        IF(rc .le. r0) THEN
           !Bx component
           q(i,6     ) = 0.0d0
           q(i,nvar+1) = q(i,6)

           !By component
           q(i,7     ) = 0.d0
           q(i,nvar+2) = q(i,7)

           !Bz component
           q(i,8     ) = B0
           q(i,nvar+3) = q(i,8)
        ELSE
           !Bx component
           q(i,6     ) = 0.0d0
           q(i,nvar+1) = q(i,6)

           !By component
           q(i,7     ) = 0.d0
           q(i,nvar+2) = q(i,7)

           !Bz component
#if HALL==1
           q(i,8     ) = B0
#else
           q(i,8     ) = B0 /(contrast**(2./3.))
#endif
           q(i,nvar+3) = q(i,8)

#if NIMHD==1
           ! Electric current
           do ivar=1,3
             q(i,firstindex_pscal+ivar)=0d0
           end do
#endif

        END IF
        sum_dust = 0.0d0
#if NDUST>0
        if(mrn) call init_dust_ratio(epsilon_0, dustMRN)
        do idust =1,ndust
           q(i, firstindex_ndust+idust)= dust_ratio(idust)/(1.0d0+dust_ratio(idust))
           if(mrn) q(i, firstindex_ndust+idust) = dustMRN(idust)
           sum_dust = sum_dust + q(i, firstindex_ndust+idust)
           if(rs.gt.r0) q(i, firstindex_ndust+idust) = q(i, firstindex_ndust+idust)/reduce_dfrac
           if(rs .gt.r0) sum_dust=sum_dust/reduce_dfrac
        end do
#endif
#if NDUST>0
#if NDUSTPSCAL>0
        do idust=1,ndust
           q(i, firstindex_dustpscal+idust) =  l_grain(idust)    
        end do
#endif        
#endif       
        if(eos)then
           call enerint_eos((1.0d0-sum_dust)*q(i,1),Temp,ee)
           q(i,5   ) = ee
           q(i,nvar) = ee
        else
           q(i,5) = q(i,1)*(1.0d0-sum_dust) * C_s**2/(gamma-1.0d0)
           q(i,nvar) = q(i,5)
        endif
     ENDDO

  else

     !do various things which needs to be done only one time
     if( first ) then 
        id=1; iu=2; iv=3; iw=4; ip=5
        pi=acos(-1.0d0)

        if(myid==1) write(*,*) '** ENTER  in condinit **'



        !calculate the mass in code units (Msolar / Mparticle / pc^3
        !    mass_c = mass_c * (Msun / (scale_d * scale_l**3) )
        !    done in calc_boxlen


        if(myid ==1) write(*,*) 'cloud mass (code units) ',mass_c

        !calculate the sound speed
        C_s = sqrt( Tr_floor / scale_T2 )


        if(myid == 1)  write(*,*) 'T_0 (K) ', Tr_floor
        if(myid == 1)  write(*,*)  'C_s (code units) ', C_s

        !cont_ic is the density contrast between the edge of the cloud and the intercloud medium
        cont_ic = 10.

        !calculate  zeta=r_ext/r_0
        zeta = sqrt(cont - 1.)


        !calculate an integral used to compute the cloud radius 
        res_int=0.
        do i=1,1000
           res_int = res_int + log(1.+(zeta/1000.*i)**2) * zeta/1000.
           mass_rad(i) = i*zeta/1000. * log(1+(zeta/1000.*i)**2) - res_int
        enddo
        res_int = zeta*log(1.+zeta**2) - res_int


        !now we determine the central density and the external cloud radius
        !we have mass = 2 pi rho_c r_0^2 z_0 * res_int
        !which results from the integration of rho = dc/(1.+(x^2+y^2)/r_O^2+z^2/z_0^2)
        !for (x^2+y^2)/r_O^2+z^2/z_0^2 < zeta
        !we also have ff_sct = sqrt(3. pi / 32 / G / d_c) C_s / (r_0 ) 
        !which just state the ratio of freefall time over sound crossing time 
        !from these 2 formula, rho_c and r_0 are found to be:

        !ph 01/09 new definition entails r_0 instead of r_0 * zeta, the external radius
        r_0 = mass_c / (2.*pi*rap*res_int) * (ff_sct)**2 / (3.*pi/32.) / C_s**2

        if (myid ==1) write(*,*) 'inner radius (pc) ',r_0

        d_c = mass_c / (2.*pi*rap*res_int) / r_0**3

        if(myid ==1) write(*,*) 'central density ',d_c

        ener_therm = 3./2.*mass_c*C_s**2
        ener_grav  = 3./5.*(mass_c**2)/(r_0*zeta)
        ener_grav2=0.
        do i=1,1000
           ener_grav2 = ener_grav2 + (i*zeta/1000.) / (1.+(zeta/1000.*i)**2) * zeta/1000. * mass_rad(i)
        enddo
        ener_grav2 = ener_grav2 * 8.*(pi**2)*(d_c**2)*(r_0**5)



        !angular velocity
        omega = ff_rt * 2.*pi * sqrt( 32.*d_c/3./pi)    
        if (myid==1) write(*,*)'Angular velocity Omega = ',omega/(2.0*pi)/scale_t, 'Hz'
        !central value of magnetic field
        !remember magnetic variable is B/sqrt(4pi)
        if(.not.uniform_bmag)then
           !ph 01/09 new definition entails r_0 instead of r_0 * zeta, the external radius
           B_c = ff_act * sqrt( 32./3./pi) * d_c * r_0 

           mass_sph = d_c / cont * (boxlen*(0.5**levelmin))**3

           !the smallest initial column density
           min_col_d = boxlen * d_c / cont / cont_ic 

           !the largest initial column density
           !obtained by integrating the density distribution through the box
           max_col_d = r_0*d_c*atan(zeta) + (boxlen -2.*r_0*zeta) * d_c / cont / cont_ic 

           if (myid==1) write(*,*) 'valeur du champ magnetique central non normalise B_c', B_c
           if (myid==1) write(*,*) 'valeur du champ magnetique a l exterieur ', B_c*min_col_d/max_col_d

           !calculate the value of mu the mass to flux over critical mass to flux ratio
           !from Mouschovias & Spitzer 1979 M/phi)_crit = 1/(3pi) * sqrt(5/G) * 0.53
           !since B(r)=B_c * sig(r)/sig(0), phi = B_c * mass_c / sig(0)
           !thus mass_c / phi = sig(0) / B_c 
           !taking into account the fact that B_c = champ mag / sqrt(4 pi)
           ! we have in code units mu = sig(0) / (B_c*sqrt(4 pi)) / (sqrt(5)/(3 pi) * 0.53)
           if (myid ==1) write(*,*) 'the mass to flux over critical mass to flux ratio in the case of a spheroidal cloud (not correct if rap ne 1)'
           if (myid ==1) then
              if (B_c.lt.1.e-10) then
                 write(*,*) 'mu= +Infinity'
              else
                 write(*,*) 'mu= ',max_col_d / (B_c*sqrt(4.*pi)) / (sqrt(5.)/(3.*pi) * 0.53)
              endif
           end if
           !note here we make the approximation that max_col_d is equal to the column density through the cloud which is note exactly 
           !the case since the column density of the external medium is also taken into account
        else
           !bc switch to uniform magnetic field if keyword uniform_bmag 
           !calculate the value of mu the mass to flux over critical mass to flux ratio at the core boundary
           !from Mouschovias & Spitzer 1979 M/phi)_crit = 1/(3pi) * sqrt(5/G) * 0.53

           B_c =mass_c*crit/(pi*(r_0*zeta)**2)/ (sqrt(5.)/(3.*pi) * 0.53)/sqrt(4.*pi)

           mass_sph = d_c / cont * (boxlen*(0.5**levelmin))**3

           !the smallest initial column density
           min_col_d = boxlen * d_c / cont / cont_ic 

           !the largest initial column density
           !obtained by integrating the density distribution through the box
           max_col_d = r_0*d_c*atan(zeta) + (boxlen -2.*r_0*zeta) * d_c / cont / cont_ic 

           if (myid ==1) write(*,*) 'the mass to flux over critical mass to flux ratio in the case of a spheroidal cloud (not correct if rap ne 1)'
           if (myid ==1) then
              if (B_c.lt.1.e-10) then
                 write(*,*) 'mu= +Infinity'
              else
                 write(*,*) 'mu= ',1.0/crit
              endif
           end if

        end if
        !now read the turbulent velocity field used as initial condition
        v_rms=0.
        mass_total=0.
        mass_tot2 =0.
        ener_turb=0.
        ener_rot=0.
        n_size=0
        vx_tot=0.d0
        vy_tot=0.d0
        vz_tot=0.d0
        vx2_tot=0.d0
        vy2_tot=0.d0
        vz2_tot=0.d0

        if(ff_vct .ne. 0)then
           if( myid ==1) write(*,*) 'Read the file which contains the initial turbulent velocity field'
           open(20,file='init_turb.data',form='formatted')
           read(20,*) n_size, ind, seed1,seed2,seed3

           if(n_size .ne. 100) then 
              write(*,*) 'Unexpected field size'
              stop
           endif

           do k=1,n_size
              do j=1,n_size
                 do i=1,n_size
                    read(20,*)xi,yi,zi,vx,vy,vz
                    q_idl(1,i,j,k) = vx
                    q_idl(2,i,j,k) = vy
                    q_idl(3,i,j,k) = vz

                    xi = boxlen*((i-0.5)/n_size-0.5)
                    yi = boxlen*((j-0.5)/n_size-0.5)
                    zi = boxlen*((k-0.5)/n_size-0.5)
                    eli =  (xi/r_0)**2+(yi/r_0)**2+(zi/(r_0*rap))**2

                    if( eli .lt. zeta**2) then

                       vx_tot = vx_tot + d_c/(1.+eli)*vx
                       vy_tot = vy_tot + d_c/(1.+eli)*vy
                       vz_tot = vz_tot + d_c/(1.+eli)*vz

                       vx2_tot = vx2_tot + d_c/(1.+eli)*vx**2
                       vy2_tot = vy2_tot + d_c/(1.+eli)*vy**2
                       vz2_tot = vz2_tot + d_c/(1.+eli)*vz**2

                       ener_turb = ener_turb + d_c/(1.+eli)*(vx**2+vy**2+vz**2)
                       mass_total = mass_total +  d_c / (1.+eli)
                    endif
                 enddo
                 !       eli = (yi/r_0)**2 + (zi/r_0/rap)**2
                 !        if( eli .lt. zeta**2) then
                 !          col_d = r_0*d_c/sqrt(1.+eli)*atan( sqrt( (zeta**2-eli)/(1.+eli) ) )
                 !          mass_tot2 = mass_tot2 + col_d
                 !        endif 
              enddo
           enddo
           close(20)

           vx_tot = vx_tot / mass_total
           vy_tot = vy_tot / mass_total
           vz_tot = vz_tot / mass_total

           vx2_tot = vx2_tot / mass_total
           vy2_tot = vy2_tot / mass_total
           vz2_tot = vz2_tot / mass_total

           v_rms = sqrt( vx2_tot-vx_tot**2 + vy2_tot-vy_tot**2 + vz2_tot-vz_tot**2 ) 

           mass_total = mass_total*(boxlen/n_size)**3
           if (myid ==1) write(*,*) 'We verify the calculation for the mass. The 2 following values must be very close:'
           if (myid ==1) write(*,*) 'mass_total, mass_c ',mass_total, mass_c !,mass_tot2

        end if

        n_size=100
        do k=1,n_size
           do j=1,n_size
              do i=1,n_size

                 xi = boxlen*((i-0.5)/n_size-0.5)
                 yi = boxlen*((j-0.5)/n_size-0.5)
                 zi = boxlen*((k-0.5)/n_size-0.5)
                 eli =  (xi/r_0)**2+(yi/r_0)**2+(zi/(r_0*rap))**2

                 if( eli .lt. zeta**2) then
                    ener_rot = ener_rot + d_c/(1.+eli) * omega**2 * (yi**2 + zi**2)
                 endif
              enddo
           enddo
        enddo


        ener_rot  = 0.5 * ener_rot*(boxlen/n_size)**3
        ener_turb = 0.5 * ener_turb*(boxlen/n_size)**3

        !estimate of the thermal over gravitational energy 
        if (myid == 1) write(*,*) 'estimate (uniform density is assumed) of the ratio of thermal over gravitational energy'
        if (myid == 1) write(*,*)  ener_therm / ener_grav

        if (myid == 1) write(*,*) 'good estimate of the ratio of thermal over gravitational energy'
        if (myid == 1) write(*,*)  ener_therm / ener_grav2

        if (myid .eq. 1) write(*,*) 'estimate of the rotational over gravitational energy ratio'
        if (myid .eq. 1) write(*,*) 'ener_rot/ener_grav2 ', ener_rot / ener_grav2, ener_rot , ener_grav2


        !calculate now the coefficient by which the turbulence velocity needs
        !to be multiplied 
        if(v_rms .ne.0)then
           if (myid .eq. 1) write(*,*) 'vrms non norm ',v_rms

           !ph 01/09 new definition entails r_0 instead of r_0 * zeta, the external radius
           v_rms = ff_vct * sqrt(32.*d_c/3./pi)*r_0 / v_rms

           if (myid .eq. 1) write(*,*) 'vrms mult ',v_rms


           !estimate of the turbulent over gravitational energy ratio
           if (myid .eq. 1) write(*,*) 'estimate of the turbulent over gravitational energy ratio'
           if (myid .eq. 1) write(*,*) 'ener_turb/ener_grav2 ', ener_turb*(v_rms**2) / ener_grav2

        end if

100     format(i5,4e12.5)
101     format(6e12.5)
102     format(i5)

        if (myid ==1)  write(*,*) 'Reading achieved'
        first = .false.
     endif

     Temp = tr_floor

     DO i=1,nn

        x(i,1) = x(i,1) - 0.5*boxlen
        x(i,2) = x(i,2) - 0.5*boxlen
        x(i,3) = x(i,3) - 0.5*boxlen

        q(i,2) = 0.0d0
        q(i,3) = 0.0d0
        q(i,4) = 0.0d0

        !initialise the density field
        eli =  (x(i,1)/r_0)**2+(x(i,2)/r_0)**2+(x(i,3)/(r_0*rap))**2

        if( eli .gt. zeta**2) then 
           q(i,1) = d_c / cont / cont_ic
           sum_dust = 0.0d0
#if NDUST>0
           if(mrn) call init_dust_ratio(epsilon_0, dustMRN)
           do idust =1,ndust
              q(i, firstindex_ndust+idust)= dust_ratio(idust)/(1.0d0+dust_ratio(idust))
              if(mrn) q(i, firstindex_ndust+idust)= dustMRN(idust)/cont/reduce_dfrac
              
              sum_dust = sum_dust + q(i, firstindex_ndust+idust)
           end do
#endif
           if(eos)then
              call enerint_eos((1.0d0-sum_dust)*q(i,1),Temp,ee)
              q(i,5) = ee
              !if the cloud is in pressure equilibrium with the surrounding medium
              !remove this line if the IC gas is isothermal as well 
              !        q(i,5) = q(i,5) * cont_ic 
              q(i,nvar) = ee
           else
              q(i,5) = q(i,1) *(1.0d0-sum_dust)* C_s**2/(gamma-1.0d0)
              q(i,nvar) = q(i,5)
           endif
        else
           q(i,1) = d_c / (1.+eli)
           sum_dust = 0.0d0
#if NDUST>0
           if(mrn) call init_dust_ratio(epsilon_0, dustMRN)
      
           do idust =1,ndust
              q(i, firstindex_ndust+idust)= dust_ratio(idust)/(1.0d0+dust_ratio(idust))
              if(mrn) q(i, firstindex_ndust+idust)= dustMRN(idust)
              
              sum_dust = sum_dust + q(i, firstindex_ndust+idust)
           end do
#endif
           if(eos)then
              call enerint_eos((1.0d0-sum_dust)*q(i,1),Temp,ee)
              q(i,5   ) = ee
              q(i,nvar) = ee
           else
              q(i,5) = q(i,1) *(1.0d0-sum_dust)* C_s**2/(gamma-1.0d0)
              q(i,nvar) = q(i,5)
           endif
        endif

#if NGRP>0
        do igroup=1,ngrp
           q(i,firstindex_er+igroup) = radiation_source(Temp,igroup)/(scale_d*scale_v**2)
        enddo
#endif

        if(v_rms .ne. 0)then
           !initialise the turbulent velocity field
           !make a zero order interpolation (should be improved)
           ind_i = int((x(i,1)/boxlen+0.5)*n_size)+1
           ind_j = int((x(i,2)/boxlen+0.5)*n_size)+1
           ind_k = int((x(i,3)/boxlen+0.5)*n_size)+1


           if( ind_i .lt. 1 .or. ind_i .gt. n_size) write(*,*) 'ind_i ',ind_i,boxlen,x(i,1),n_size
           if( ind_j .lt. 1 .or. ind_j .gt. n_size) write(*,*) 'ind_j ',ind_j
           if( ind_k .lt. 1 .or. ind_k .gt. n_size) write(*,*) 'ind_k ',ind_k

           q(i,2) = v_rms*(q_idl(1,ind_i,ind_j,ind_k)-vx_tot)
           q(i,3) = v_rms*(q_idl(2,ind_i,ind_j,ind_k)-vy_tot)
           q(i,4) = v_rms*(q_idl(3,ind_i,ind_j,ind_k)-vz_tot)

        end if

        !add  rotation. x cos(theta_mag_radians) + y sin(theta_mag_radians) is the rotation axis
        sph =  (x(i,1)/r_0)**2+(x(i,2)/r_0)**2+(x(i,3)/(r_0))**2
        if( sph .lt. (zeta*rap)**2 ) then 

           !to check these formulae one can verify that those arrays are perpendicular
           !with (cos(theta_mag_radians),sin(theta_mag_radians),0) and that the norm of the vectorial product of
           ! (cos(theta_mag_radians),sin(theta_mag_radians),0) by the above arrays is equal to the distance
           !  (x sin(thet)-y cos(thet))^2 + z^2 
           q(i,2) = q(i,2) - (omega*x(i,3)*sin(theta_mag_radians))
           q(i,3) = q(i,3) + (omega*x(i,3)*cos(theta_mag_radians))
           q(i,4) = q(i,4) + (omega*(x(i,1)*sin(theta_mag_radians)-x(i,2)*cos(theta_mag_radians)))

        endif


     ENDDO

     if(uniform_bmag) then

        DO i=1,nn
           q(i,6     ) = B_c
           q(i,nvar+1) = q(i,6)
           
           !By component
           q(i,7     ) = 0.
           q(i,nvar+2) = 0.
           
           !Bz component
           q(i,8     ) = 0.
           q(i,nvar+3) = 0.

        end DO
           
     else

        dxmin=boxlen*0.5d0**(levelmin+3)
        
        if( dx .lt. dxmin) then 
           write(*,*) 'dxmin too large'
           write(*,*) 'dx ',dx/boxlen
           write(*,*) 'dxmin ',dxmin/boxlen
           stop
        endif

        nticks=dx/dxmin



        DO i=1,nn
           q(i,6)=0.
           
           xl=x(i,1)-0.5*dx
           yl=x(i,2)-0.5*dx
           zl=x(i,3)-0.5*dx
           
           
           !the magnetic field in cells must be subdivided in order to insure that the magnetic
           !flux is the same in coarse and refined grids
           DO jj=1,nticks
              DO kk=1,nticks
                 
                 yy=yl+(dble(jj)-0.5d0)*dxmin
                 zz=zl+(dble(kk)-0.5d0)*dxmin

                 !this formula comes from the integration of the density distribution along x
                 eli = (yy/r_0)**2 + (zz/r_0/rap)**2
                 if( eli .lt. zeta**2) then
                    col_d = r_0*d_c/sqrt(1.+eli)*atan( sqrt( (zeta**2-eli)/(1.+eli) ) )
                    col_d = max(col_d,min_col_d)
                 else 
                    col_d = min_col_d
                 endif
                 
                 !Bx component
                 if(uniform_bmag)then
                    q(i,6     ) = q(i,6) + B_c
                 else
                    q(i,6     ) = q(i,6) + B_c * col_d / max_col_d
                 end if
                 q(i,nvar+1) = q(i,6)

                 !By component
                 q(i,7     ) = 0.
                 q(i,nvar+2) = 0.
                 
                 !Bz component
                 q(i,8     ) = 0.
                 q(i,nvar+3) = 0.

              ENDDO
           ENDDO

           q(i,6:8)           = q(i,6:8)           / dble(nticks)**2

           !new version rotates the rotation velocity 
           !rotates the magnetic field of an angle theta
           !       bx=q(i,6)
           !       by=q(i,7)
           !       q(i,6) =  bx*cos(theta_mag_radians) + by*sin(theta_mag_radians)
           !       q(i,7) =  bx*sin(theta_mag_radians) - by*cos(theta_mag_radians)
           
           q(i,nvar+1:nvar+3) = q(i,6:8)
        ENDDO
     end if
  end if

  ! Convert primitive to conservative variables
  ! density -> density
  u(1:nn,1)=q(1:nn,1)
  ! velocity -> momentum
  u(1:nn,2)=q(1:nn,1)*q(1:nn,2)
  u(1:nn,3)=q(1:nn,1)*q(1:nn,3)
  u(1:nn,4)=q(1:nn,1)*q(1:nn,4)
  ! kinetic energy
  u(1:nn,5)=0.0d0
  u(1:nn,5)=u(1:nn,5)+0.5*q(1:nn,1)*q(1:nn,2)**2
  u(1:nn,5)=u(1:nn,5)+0.5*q(1:nn,1)*q(1:nn,3)**2
  u(1:nn,5)=u(1:nn,5)+0.5*q(1:nn,1)*q(1:nn,4)**2
  ! pressure -> total fluid energy
  u(1:nn,5)=u(1:nn,5)+q(1:nn,5)
  ! magnetic energy -> total fluid energy
  u(1:nn,5)=u(1:nn,5)+0.125d0*(q(1:nn,6)+q(1:nn,nvar+1))**2
  u(1:nn,5)=u(1:nn,5)+0.125d0*(q(1:nn,7)+q(1:nn,nvar+2))**2
  u(1:nn,5)=u(1:nn,5)+0.125d0*(q(1:nn,8)+q(1:nn,nvar+3))**2
  u(1:nn,6:8)=q(1:nn,6:8)
  u(1:nn,nvar+1:nvar+3)=q(1:nn,nvar+1:nvar+3)
#if NENER>0
  ! non-thermal pressure -> non-thermal energy
  ! non-thermal energy   -> total fluid energy
  do ivar=1,nener-ngrp
     u(1:nn,8+ivar)=q(1:nn,8+ivar)/(gamma_rad(ivar)-1.0d0)
     u(1:nn,5)=u(1:nn,5)+u(1:nn,8+ivar)
  enddo
 ! Radiative transfer
#if NGRP>0
  ! radiative energy   -> total fluid energy
  do ivar=1,ngrp
     u(1:nn,firstindex_er+ivar)= q(1:nn,firstindex_er+ivar)
     u(1:nn,5)=u(1:nn,5)+ u(1:nn,firstindex_er+ivar)
  enddo
#if USE_M_1==1
  ! radiative flux
  do ivar=1,ndim*ngrp
     do i=1,ncache
        u(1:nn,fisrtindex_fr+ivar)=q(1:nn,firstindex+ivar)
     end do
     write(ilun)xdp
  end do
#endif
#endif
#endif
#if NEXTINCT>0
  ! Extinction
  if(extinction)u(1:nn,firstindex_extinct+nextinct)=0.0D0
#endif
#if NPSCAL>0
  ! passive scalars
  do ivar=1,npscal
     u(1:nn,firstindex_pscal+ivar)=q(1:nn,1)*q(1:nn,firstindex_pscal+ivar)
  end do
  ! Internal energy
  u(1:nn,nvar)=q(1:nn,5)
#endif
  
!Dust  passive scalars
#if NDUST>0
#if NDUSTPSCAL>0
  do idust=1,ndust
     do ivar=1,ndust_pscal
          u(1:nn,firstindex_dustpscal+(ivar-1)*ndust+idust)=q(1:nn,1)*q(1:nn,firstindex_ndust+idust)*q(1:nn,firstindex_dustpscal+(ivar-1)*ndust+idust)
       end do
  end do
#endif
#endif

  
end subroutine condinit
!================================================================
!================================================================
!================================================================
!================================================================
subroutine velana(x,v,dx,t,ncell)
  use amr_parameters
  use hydro_parameters  
  implicit none
  integer ::ncell                         ! Size of input arrays
  real(dp)::dx                            ! Cell size
  real(dp)::t                             ! Current time
  real(dp),dimension(1:nvector,1:3)::v    ! Velocity field
  real(dp),dimension(1:nvector,1:ndim)::x ! Cell center position.
  !================================================================
  ! This routine computes the user defined velocity fields.
  ! x(i,1:ndim) are cell center position in [0,boxlen] (user units).
  ! v(i,1:3) is the imposed 3-velocity in user units.
  !================================================================
  integer::i
  real(dp)::xx,yy,zz,vx,vy,vz,rr,tt,omega,aa,twopi

  ! Add here, if you wish, some user-defined initial conditions
!!   aa=1.0
!!   twopi=2d0*ACOS(-1d0)
!!   do i=1,ncell
!! 
!!      xx=x(i,1)
!! #if NDIM > 1
!!      yy=x(i,2)
!! #endif
!! #if NDIM > 2
!!      zz=x(i,3)
!! #endif
!!      ! ABC
!!      vx=aa*(cos(twopi*yy)+sin(twopi*zz))
!!      vy=aa*(sin(twopi*xx)+cos(twopi*zz))
!!      vz=aa*(cos(twopi*xx)+sin(twopi*yy))
!! 
!!      ! 1D advection test
!!      vx=1.0_dp
!!      vy=0.0_dp
!!      vz=0.0_dp

!!      ! Ponomarenko
!!      xx=xx-boxlen/2.0
!!      yy=yy-boxlen/2.0
!!      rr=sqrt(xx**2+yy**2)
!!      if(yy>0)then
!!         tt=acos(xx/rr)
!!      else
!!         tt=-acos(xx/rr)+twopi
!!      endif
!!      if(rr<1.0)then
!!         omega=0.609711
!!         vz=0.792624
!!      else
!!         omega=0.0
!!         vz=0.0
!!      endif
!!      vx=-sin(tt)*rr*omega
!!      vy=+cos(tt)*rr*omega
     
!!      v(i,1)=vx
!! #if NDIM > 1
!!      v(i,2)=vy
!! #endif
!! #if NDIM > 2
!!      v(i,3)=vz
!! #endif
!!   end do


end subroutine velana
!========================================================================================
!========================================================================================
!========================================================================================
!========================================================================================
subroutine calc_boxlen
  use amr_commons
  use hydro_commons
  use poisson_parameters
  use radiation_parameters
  use cooling_module,ONLY:kB,mH
  use units_commons
  use cloud_module
  
  implicit none
  !================================================================
  !this routine calculate boxlen
  !================================================================
  integer :: i
  real(dp):: pi
  real(dp):: d_c,zeta
  real(dp):: res_int,r_0,C_s
  integer::  np
  logical,save:: first=.true.
  real(dp) :: sum_dust
#if NDUST>0
  integer :: idust
  real(dp):: epsilon_0
  real(dp),dimension(1:ndust):: dustMRN
  epsilon_0 = dust_ratio(1)
#endif  
    if (first) then

    pi=acos(-1.0d0)

    !calculate the mass in code units (Msolar / Mparticle / pc^3
    mass_c = mass_c * (Msun / scale_m )

    !calculate the sound speed
    C_s = sqrt( Tr_floor / scale_T2 )

    
    if(bb_test)then
       sum_dust=0.0d0
#if NDUST>0
       do idust =1,ndust
          dustMRN(idust) = dust_ratio(idust)/(1.0d0+dust_ratio(idust))
       end do
       if(mrn) call init_dust_ratio(epsilon_0, dustMRN)
     do idust =1,ndust
        sum_dust = sum_dust + dustMRN(idust)
     end do
#endif   
     r_0 = (alpha_dense_core*2.*6.67d-8*mass_c*mu_gas*mH/(5.*kB*Tr_floor*(1.0d0-sum_dust)))/scale_l* scale_m 
       boxlen = r_0 * r0_box
       
       if (myid == 1) then 
          write(*,*) '** Cloud parameters estimated in calc-boxlen **' 
          write(*,*) 'inner radius (pc) ', r_0
          write(*,*) 'total box length (pc) ', boxlen
          write(*,*) 'cloud mass (code units) ', mass_c
          write(*,*) 
       endif
   
    else
       !calculate  zeta=r_ext/r_0
       zeta = sqrt(cont - 1.)
       
       !calculate an integral used to compute the cloud radius 
       np=1000
       res_int=0.
       do i=1,np
          res_int = res_int + log(1.+(zeta/np*i)**2) * zeta/np
       enddo
       res_int = zeta*log(1.+zeta**2) - res_int
       
       !now we determine the central density and the external cloud radius
       !we have mass = 2 pi rho_c r_0^2 z_0 * res_int
       !which results from the integration of rho = dc/(1.+(x^2+y^2)/r_O^2+z^2/z_0^2)
       !for (x^2+y^2)/r_O^2+z^2/z_0^2 < zeta
       !we also have ff_sct = sqrt(3. pi / 32 / G / d_c) C_s / (r_0) 
       !which just state the ratio of freefall time over sound crossing time 
       !from these 2 formula, rho_c and r_0 are found to be:
       
       
       
       r_0 = mass_c / (2.*pi*rap*res_int) * (ff_sct)**2 / (3.*pi/32.) / C_s**2

       d_c = mass_c / (2.*pi*rap*res_int) / r_0**3
       
       !it is equal to twice the length of the major axis
       boxlen = r_0 * zeta * max(rap,1.) * 4.
       
       if (myid == 1) then 
          write(*,*) '** Cloud parameters estimated in calc-boxlen **' 
          write(*,*) 'inner radius (pc) ', r_0 
          write(*,*) 'peak density (cc) ', d_c
          write(*,*) 'total box length (pc) ', boxlen
          write(*,*) 'cloud mass (code units) ', mass_c
          write(*,*) 
       endif
       
    endif
       
    first=.false.
 endif

end subroutine calc_boxlen  
!========================================================================================
!========================================================================================
!========================================================================================
!========================================================================================
function compute_db()
  use hydro_commons
  use radiation_parameters
  use cooling_module,ONLY:kB,mH
  use units_commons
  use cloud_module
  
  implicit none

  integer::i
  real(dp)::res_int,d0,r0,pi,c_s,zeta,compute_db,mass_c2
 real(dp):: sum_dust
#if NDUST>0
  integer :: idust
  real(dp):: epsilon_0
  real(dp),dimension(1:ndust):: dustMRN
  epsilon_0 = dust_ratio(1)
#endif  
  C_s = sqrt( Tr_floor / scale_T2 )
  pi=acos(-1.0d0)

  !calculate  zeta=r_ext/r_0
  zeta = sqrt(cont - 1.)
  mass_c2 = mass_c * (Msun / scale_m )     

  if(bb_test)then
     sum_dust=0.0d0
#if NDUST>0
     do idust =1,ndust
        dustMRN(idust) = dust_ratio(idust)/(1.0d0+dust_ratio(idust))
     end do     
     if(mrn) call init_dust_ratio(epsilon_0, dustMRN)
     do idust =1,ndust
           sum_dust = sum_dust + dustMRN(idust)
        end do   
#endif           
     pi=2.0d0*asin(1.0d0)
     r0=(alpha_dense_core*2.*6.67d-8*mass_c2*scale_m*mu_gas*mH/(5.*kB*Tr_floor*(1.0d0-sum_dust)))/scale_l
     d0 = 3.0d0*mass_c2/(4.0d0*pi*r0**3.)
     compute_db=d0/contrast
     
  else
     !calculate an integral used to compute the cloud radius 
     res_int=0.
     do i=1,1000
        res_int = res_int + log(1.+(zeta/1000.*i)**2) * zeta/1000.
      enddo
     res_int = zeta*log(1.+zeta**2) - res_int
     

     !now we determine the central density and the external cloud radius
     !we have mass = 2 pi rho_c r_0^2 z_0 * res_int
     !which results from the integration of rho = dc/(1.+(x^2+y^2)/r_O^2+z^2/z_0^2)
     !for (x^2+y^2)/r_O^2+z^2/z_0^2 < zeta
     !we also have ff_sct = sqrt(3. pi / 32 / G / d_c) C_s / (r_0 ) 
     !which just state the ratio of freefall time over sound crossing time 
     !from these 2 formula, rho_c and r_0 are found to be:
     
     !ph 01/09 new definition entails r_0 instead of r_0 * zeta, the external radius
     r0 = mass_c2 / (2.*pi*rap*res_int) * (ff_sct)**2 / (3.*pi/32.) / C_s**2
               
     d0 = mass_c2 / (2.*pi*rap*res_int) / r0**3

     compute_db=d0 / cont / 10.
     
  end if
  
  return
  
end function compute_db
../patch/collapse/cooling_fine.f90
subroutine cooling_fine(ilevel)
  use amr_commons
  use hydro_commons
  use cooling_module
#ifdef grackle
  use grackle_parameters
#endif
  implicit none
#ifndef WITHOUTMPI
  include 'mpif.h'
#endif
  integer::ilevel
  !-------------------------------------------------------------------
  ! Compute cooling for fine levels
  !-------------------------------------------------------------------
  integer::ncache,i,igrid,ngrid,info
  integer,dimension(1:nvector),save::ind_grid
  real(dp)::scale_nH,scale_T2,scale_l,scale_d,scale_t,scale_v
  ! files
  character(LEN=5)                    :: nsort, nocpu
  character(LEN = 80)                 :: filenamex,filenamey,filenamez
  integer::uleidx,uleidy,uleidz
  
  if(numbtot(1,ilevel)==0)return
  if(verbose)write(*,111)ilevel

  !  if(myid .EQ. 1) write(*,*) 'STATUS: starting cooling_fine, ilevel=', ilevel
  ! Valeska
  !--------------------------------------------------------------------
  ! The write option permits us to construct a column density map projected 
  ! in x, y, and z by calculating the column densities along positive and 
  ! negative directions with respect to a slice that passes through the 
  ! respective mid planes.
  !--------------------------------------------------------------------
  if(writing) then
     call title(ifout-1, nsort)
     call title(myid, nocpu)
     filenamex= TRIM(nsort)//'_test_densX_'//TRIM(nocpu)//'.dat'        !ex.:00001_test_densX_00010.dat
     filenamey= TRIM(nsort)//'_test_densY_'//TRIM(nocpu)//'.dat'
     filenamez= TRIM(nsort)//'_test_densZ_'//TRIM(nocpu)//'.dat'
     
     uleidx = myid + 100                                                !integer
     uleidy = myid + 200
     uleidz = myid + 300
     
     open(unit=uleidx, file=filenamex, form='formatted', status='unknown',position='append')
     open(unit=uleidy, file=filenamey, form='formatted', status='unknown',position='append')
     open(unit=uleidz, file=filenamez, form='formatted', status='unknown',position='append')
  end if
  !--------------------------------------------------------------------
  ! Valeska

  ! Operator splitting step for cooling source term
  ! by vector sweeps
  ncache=active(ilevel)%ngrid
  do igrid=1,ncache,nvector
     ngrid=MIN(nvector,ncache-igrid+1)
     do i=1,ngrid
        ind_grid(i)=active(ilevel)%igrid(igrid+i-1)
     end do
     call coolfine1(ind_grid,ngrid,ilevel)
  end do

  if((cooling.and..not.neq_chem).and.ilevel==levelmin.and.cosmo)then
#ifdef grackle
     if(use_grackle==0)then
        if(myid==1)write(*,*)'Computing new cooling table'
        call set_table(dble(aexp)) 
     endif
#else
     if(myid==1)write(*,*)'Computing new cooling table'
     call set_table(dble(aexp))
#endif
  endif
  
111 format('   Entering cooling_fine for level',i2)

end subroutine cooling_fine
!###########################################################
!###########################################################
!###########################################################
!###########################################################
subroutine coolfine1(ind_grid,ngrid,ilevel)
  use amr_commons
  use hydro_commons
  use cooling_module
  use radiation_parameters, ONLY: sinks_opt_thin
#ifdef grackle
  use grackle_parameters
#endif
#ifdef ATON
  use radiation_commons, ONLY: Erad
#endif
#ifdef RT
  use rt_parameters, only: nGroups, iGroups
  use rt_hydro_commons
  use rt_cooling_module, only: rt_solve_cooling,iIR,rt_isIRtrap &
       ,rt_pressBoost,iIRtrapVar,kappaSc,a_r,is_kIR_T,rt_vc
#endif
  implicit none
#ifndef WITHOUTMPI
  include 'mpif.h'
#endif
  integer::ilevel,ngrid
  integer,dimension(1:nvector)::ind_grid
  !-------------------------------------------------------------------
  !-------------------------------------------------------------------
  integer::i,ind,iskip,idim,nleaf,nx_loc,ix,iy,iz,info
  real(dp)::scale_nH,scale_T2,scale_l,scale_d,scale_t,scale_v
  real(kind=8)::dtcool,nISM,nCOM,damp_factor,cooling_switch,t_blast
  real(dp)::polytropic_constant
  integer,dimension(1:nvector),save::ind_cell,ind_leaf,ind_leaf_loc
  real(kind=8),dimension(1:nvector),save::nH,T2,T2_new,delta_T2,ekk,err,emag
  real(kind=8),dimension(1:nvector),save::T2min,Zsolar,boost
  real(dp),dimension(1:3)::skip_loc
  real(kind=8)::dx,dx_loc,scale,vol_loc
  integer::irad
  logical,dimension(1:nvector),save::insink !!!raph 28/04/2020 for sink opt thin
#ifdef RT
  integer::ig,iNp,il
  real(kind=8),dimension(1:nvector),save:: ekk_new
  logical,dimension(1:nvector),save::cooling_on=.true.
  real(dp)::scale_Np,scale_Fp,work,Npc,fred,Npnew, kScIR, EIR, TR
  real(dp),dimension(1:ndim)::Fpnew
  real(dp),dimension(nIons, 1:nvector),save:: xion
  real(dp),dimension(nGroups, 1:nvector),save:: Np, Np_boost=0d0, dNpdt=0d0
  real(dp),dimension(ndim, nGroups, 1:nvector),save:: Fp, Fp_boost, dFpdt
  real(dp),dimension(ndim, 1:nvector),save:: p_gas, u_gas
  real(kind=8)::f_trap, NIRtot, EIR_trapped, unit_tau, tau, Np2Ep, aexp_loc
  real(dp),dimension(nDim, nDim):: tEdd ! Eddington tensor
  real(dp),dimension(nDim):: flux 
#endif

  real(dp) :: barotrop1D,mincolumn_dens
  real(dp)                                   :: x0, y0, z0,coeff_chi,cst2, coef
  double precision                           :: v_extinction,extinct
  integer::uleidx,uleidy,uleidz,uleidh,igrid,ii,indc2,iskip2,ind_ll

  real(dp),dimension(1:twotondim,1:3)        :: xc                                               !xc: coordinates of center/center grid

  !-------------- SPHERICAL DIRECTIONS ------------------------------------------------!
!  real(dp),dimension(1:nvector,1:ndir)                 :: col_dens                     !
  real(dp),dimension(1:nvector,1:NdirExt_m,1:NdirExt_n):: column_dens,column_dens_loc  !
  real(dp),dimension(1:nvector,1:NdirExt_m,1:NdirExt_n):: H2column_dens,H2column_dens_loc  ! H2 column density
!  real(dp),dimension(ndir)                             :: vcol_dens                    !
  real(dp),dimension(1:NdirExt_m,1:NdirExt_n)          :: vcolumn_dens
  real(dp),dimension(1:3)                              :: xpos
  real(dp)                                             :: dx_cross_int, dx_cross_loc
  integer                                              :: index_m,index_n, mmmm,nnnn
  integer                                              :: m, n, mloop, nloop, nl   
  integer, dimension(1:NdirExt_n)                      :: deltan1, deltan2
  integer                                              :: deltam

  real(dp) :: sum_dust
#if NDUST>0
  integer :: idust
#endif  
  !-----   simple_chem   --------------------------------------------------------------!

  !Valeska
!  vcol_dens(:) = 0.
  column_dens(:,:,:) = 0.
  H2column_dens(:,:,:) = 0.
  vcolumn_dens(:,:) = 0.
  
  if(writing) then
     !---position of reference to calculate the column density maps---
     ! we add 1.0D-09 in order to avoid the exact center (there are not cells centered in 0.5L)
     x0 = 0.5D0 + 1.0D-09
     y0 = 0.5D0 + 1.0D-09
     z0 = 0.5D0 + 1.0D-09
     
     !---Units uleidx, uleidy, uleidz---
     uleidx = myid + 100
     uleidy = myid + 200
     uleidz = myid + 300
  end if
  
294 FORMAT(I10,4ES14.5) 
295 FORMAT(5ES14.5)   
296 FORMAT(I10,5ES14.5)                
  
  if(numbtot(1,ilevel)==0)return
  
  !get the column density within the box from the grid faces

  !-----   EXTERNAL CONTRIBUTION   -----
  if(extinction)  call column_density(ind_grid,ngrid,ilevel,column_dens,H2column_dens) 
  !Valeska

  ! Mesh spacing in that level
  dx=0.5D0**ilevel
  nx_loc=(icoarse_max-icoarse_min+1)
  skip_loc=(/0.0d0,0.0d0,0.0d0/)
  if(ndim>0)skip_loc(1)=dble(icoarse_min)
  if(ndim>1)skip_loc(2)=dble(jcoarse_min)
  if(ndim>2)skip_loc(3)=dble(kcoarse_min)
  scale=boxlen/dble(nx_loc)
  dx_loc=dx*scale
  vol_loc=dx_loc**ndim

  ! Conversion factor from user units to cgs units
  call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)
#ifdef RT
  call rt_units(scale_Np, scale_Fp)
#endif

  !Valeska
  !--- Set position of cell centers relative to grid center ---
  do ind=1,twotondim
     iz=(ind-1)/4                               !0 for ind=1,2,3,4; 1 for ind=5,6,7,8
     iy=(ind-1-4*iz)/2
     ix=(ind-1-2*iy-4*iz)
     if(ndim>0)xc(ind,1)=(dble(ix)-0.5_dp)*dx   
     if(ndim>1)xc(ind,2)=(dble(iy)-0.5_dp)*dx
     if(ndim>2)xc(ind,3)=(dble(iz)-0.5_dp)*dx
  end do

!******************************************************
!--- GEOMETRICAL CORRECTIONS:  Internal and Local -----
!  do ind=1,twotondim
!     xpos(1) = xc(ind,1)
!     xpos(2) = xc(ind,2)
!     xpos(3) = xc(ind,3)
!     
!     do index_m = 1,NdirExt_m
!        do index_n = 1,NdirExt_n
!           call get_dx(xpos,xpos,index_m,index_n,dx,dx_cross_int)        
!           Mdx_cross_int2(index_m,index_n) = dx_cross_int/2.0_dp
!        end do
!     end do
!     
!     do ii=1,twotondim
!        if(ii .NE. ind) then
!           xcell(1) = xc(ii,1)
!           xcell(2) = xc(ii,2)
!           xcell(3) = xc(ii,3)
!           call get_mn(xpos,xcell, m,n)
!           Mdirection2(ind,ii) = m
!           Ndirection2(ind,ii) = n
!           
!           do index_m=1,NdirExt_m  
!              do index_n=1,NdirExt_n
!                 call get_dx(xpos,xcell,index_m,index_n,dx,dx_cross_loc)
!                 Mdx_cross_loc2(ind,ii,index_m,index_n) = dx_cross_loc
!              end do
!           end do
!        end if
!     end do
!
!  end do
!----------------------------------------------------
!******************************************************


  !---  PRECALCULATION of  m, n loop limits  ------------------------------------------
  ! each cell can contribute to the column density in several directions, then
  ! we define here the limits for the loop around the direction to the cell center.
  ! For the vertical directions (m =1, NdirExt_m), the azimuthal angle has to cover 2*pi,
  ! for other directions we use +/- 1/8 of the total directions 
  !-------------------------------------------------------------------------------------
  if(extinction)then
     do m = 1, NdirExt_m
        if(m .EQ. 1 .OR. m .EQ. NdirExt_m) then
           deltan1(m) = INT(NdirExt_n/2.0_dp)
           deltan2(m) = deltan1(m) -1
        else
           deltan1(m) = INT(NdirExt_n/8)
           deltan2(m) = deltan1(m)
        end if
     end do
     deltam = INT((NdirExt_m-1)/4.)
  end if
  !-------------------------------------------------------------------------------------
  !Valeska

  ! Typical ISM density in H/cc
  nISM = n_star; nCOM=0d0
  if(cosmo)then
     nCOM = del_star*omega_b*rhoc*(h0/100.)**2/aexp**3*X/mH
  endif
  nISM = MAX(nCOM,nISM)

  ! Polytropic constant for Jeans length related polytropic EOS
  if(jeans_ncells>0)then
     polytropic_constant=2d0*(boxlen*jeans_ncells*0.5d0**dble(nlevelmax)*scale_l/aexp)**2/ &
          & (twopi)*6.67e-8*scale_d*(scale_t/scale_l)**2
  endif

#ifdef RT
#if NGROUPS>0
  if(rt_isIRtrap) then
     ! For conversion from photon number density to photon energy density:
     Np2Ep = scale_Np * group_egy(iIR) * ev_to_erg                       &
           * rt_pressBoost / scale_d / scale_v**2
  endif
#endif
  aexp_loc=aexp
  ! Allow for high-z UV background in noncosmo sims:
  if(.not. cosmo .and. haardt_madau .and. aexp_ini .le. 1.)              &
       aexp_loc = aexp_ini
#endif

  ! Loop over cells
  do ind=1,twotondim
     iskip=ncoarse+(ind-1)*ngridmax
     do i=1,ngrid
        ind_cell(i)=iskip+ind_grid(i)
     end do

     ! Gather leaf cells
     nleaf=0
     do i=1,ngrid
        if(son(ind_cell(i))==0)then
           nleaf=nleaf+1
           ind_leaf(nleaf)=ind_cell(i)
           ind_leaf_loc(nleaf)=i       !index within local group of cells
        end if
     end do
     if(nleaf.eq.0)cycle

     ! Compute rho
     do i=1,nleaf
        nH(i)=MAX(uold(ind_leaf(i),1),smallr)
     end do

#if NEXTINCT>0
     do i=1,nleaf                                  !loop over leaf cells 
        ind_ll=ind_leaf_loc(i)
        
        igrid=ind_grid(ind_leaf_loc(i))            !index father  
        
        xpos(1) = xg(igrid,1) + xc(ind,1)          !grid position + leaf position relative to grid center
        xpos(2) = xg(igrid,2) + xc(ind,2)
        xpos(3) = xg(igrid,3) + xc(ind,3)
               
        if(extinction) then
           
           !------     +  INTERNAL CONTRIBUTION        ------
           ! Here we sum up the contribution due to the cell itself. Its 1/2 in each direction.
           
           do index_n=1,NdirExt_n      !loop over directions to compute the screaning of half the cells on itself 
              do index_m=1,NdirExt_m 
                 
                 column_dens_loc(ind_ll,index_m,index_n) = column_dens(ind_ll,index_m,index_n) + dx*Mdx_cross_int(index_m,index_n)*nH(i)
#if NSCHEM != 0
                 H2column_dens_loc(ind_ll,index_m,index_n) = H2column_dens(ind_ll,index_m,index_n) + dx*Mdx_cross_int(index_m,index_n)*nH2(i)
                 !if(isnan(H2column_dens_loc(ind_ll,mloop,nl))) write(*,*) 'WARNING: INT',H2column_dens(ind_ll,index_m,index_n), nH2(i), Mdx_cross_int(index_m,index_n), dx, index_m, index_n
#endif                 
                 !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~         
                 ! column_dens_loc(ind_ll,index_m,index_n) = dx*Mdx_cross_int(index_m,index_n)*nH(i) !if just internal contribution is needed
                 ! column_dens_loc(ind_ll,index_m,index_n) = column_dens(ind_ll,index_m,index_n)  !if just the external component is needed
                 !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              end do
           end do
           
           !-------     + LOCAL CONTRIBUTION     -----
           ! and here we add the contributon due to its siblings (in the same oct).
           
           do ii=1,twotondim    !1-8 the cell in the oct! 
              if(ii .NE. ind) then
                 
                 iskip2  = ncoarse+(ii-1)*ngridmax 
                 indc2   = iskip2+ ind_grid(ind_ll) !indice for the cell crossed along the direction ind_dir
                 
                 !--------------------------------------------------  
                 !  !we calculate the position of the cell crossed
                 !  xcell(1)= xg(igrid,1) + xc(ii,1)
                 !  xcell(2)= xg(igrid,2) + xc(ii,2)
                 !  xcell(3)= xg(igrid,3) + xc(ii,3)
                 !  call get_mn(xpos, xcell, m, n)
                 !  if(m .NE. Mdirection(ind,ii) .OR. n .NE. Ndirection(ind,ii)) write(*,*) ind,ii
                 !  if(myid .EQ.1 .AND. ii .EQ. 8  ) write(*,*) ind, i, ii, '     m,n:', m, n
                 !-------------------------------------------------
                 

                 ! knowing the index of the target cell and the sibling cell we can find 
                 ! the closest direction from the target cell center to the sibling cell center.
                
!                 if(isnan(uold(indc2,neulS+1))) write(*,*) 'WARNING LOC: nH2 is NaN: ', xpos/dx    !i, ii, uold(indc2,1), uold(indc2,neulS+1), xpos
                 m = Mdirection(ind,ii)
                 n = Ndirection(ind,ii)
                 
                 ! Here we make a loop around the direction m,n in order to treat all the 
                 ! concerned directions by the sibling cell
                 
                 do mloop = max(1, m-deltam), min(NdirExt_m, m+deltam)  !avoid forbidden intervals
                    do nloop = -deltan1(mloop) -1, deltan2(mloop) -1
                       ! the value of nloop is cyclic
                       nl = 1+ mod(n+ nloop+ NdirExt_n, NdirExt_n)
                       
                       ! Here we sum up the contribution to the column density. The distance crossed
                       ! through the cell can be found using the corrective factor Mdx_cross_loc, that
                       ! depends on the relative positions in the oct and on the direction
                       
                       column_dens_loc(ind_ll,mloop,nl) = column_dens_loc(ind_ll,mloop,nl) + dx*Mdx_cross_loc(ind,ii,mloop,nl)*uold(indc2,1)        
#if NSCHEM != 0
!                       if(isnan(uold(indc2,neulS+1))) write(*,*) 'WARNING LOC: nH2 is NaN: ', uold(indc2,1), uold(indc2,neulS+1), Mdx_cross_loc(ind,ii,mloop,nl) 
!                       if(Mdx_cross_loc(ind,ii,mloop,nl) .NE. 0.0) H2column_dens_loc(ind_ll,mloop,nl) = H2column_dens_loc(ind_ll,mloop,nl) + dx*Mdx_cross_loc(ind,ii,mloop,nl)*uold(indc2,neulS+1)  
                       if(Mdx_cross_loc(ind,ii,mloop,nl) .NE. 0.0) H2column_dens_loc(ind_ll,mloop,nl) = H2column_dens_loc(ind_ll,mloop,nl) + dx*Mdx_cross_loc(ind,ii,mloop,nl)*uold(indc2,1)        
!                       if(isnan(H2column_dens_loc(ind_ll,mloop,nl))) write(*,*) 'WARNING: LOC', uold(indc2,neulS+1), Mdx_cross_loc(ind,ii,mloop,nl), mloop, nloop, nl, dx, ind, ii
!                       if(isnan(uold(indc2,neulS+1)) .AND. Mdx_cross_loc(ind,ii,mloop,nl) .NE. 0.0) write(*,*) 'WARNING LOC: nH2 is NaN and Mdx ne 0 !!!', uold(indc2,1), uold(indc2,neulS+1), Mdx_cross_loc(ind,ii,mloop,nl) 
#endif
                    end do
                 end do
                 
              end if      !ii ne ind
           end do         !ii
  
           !--- HERE THE VALUE IN COLUMN_DENS_LOC IS THE TOTAL VALUE ---

           !-- WRITE FILES for a test ---        
           if(writing .and. mod(nstep_coarse,foutput)==0) then
              
              ! we calculate here the value of the extinction just to write the files. This value is not used here and its calculated after.
              coef = 2.d-21 *scale_l* boxlen
              v_extinction=0.
              do index_m=1,NdirExt_m
                 do index_n=1,NdirExt_n
                    v_extinction= v_extinction+ exp(-column_dens_loc(ind_ll,index_m,index_n)*coef)
                 end do
              end do
              v_extinction= v_extinction/(NdirExt_m*NdirExt_n)
              
              ! we calculate the closest directions to the +/- cartesian directions 
              mmmm=NINT((NdirExt_m-1.)/2.)+1     ! (5-1)/2 +1 = 3 ok
              nnnn=NINT(NdirExt_n/2.)+1          !     8/2 +1 = 5 ok  

              if(abs(xpos(1)-x0) .LT. 0.5*dx) write(uleidx,296) ilevel, xpos(2), xpos(3), column_dens_loc(ind_ll,mmmm,1), column_dens_loc(ind_ll,mmmm,NdirExt_n/2+1), v_extinction   !Write column density
              if(abs(xpos(2)-y0) .LT. 0.5*dx) write(uleidy,296) ilevel, xpos(1), xpos(3), column_dens_loc(ind_ll,mmmm,NdirExt_n/4+1), column_dens_loc(ind_ll,mmmm,3*NdirExt_n/4+1), v_extinction
              if(abs(xpos(3)-z0) .LT. 0.5*dx) write(uleidz,296) ilevel, xpos(1), xpos(2), column_dens_loc(ind_ll,1,1), column_dens_loc(ind_ll,NdirExt_m,nnnn), v_extinction 
              
           end if

           do index_m=1,NdirExt_m
              do index_n=1,NdirExt_n
                 vcolumn_dens(index_m,index_n)=column_dens_loc(ind_ll,index_m,index_n)          
              end do
           end do

           !---  we calculate the extinction using the column density   ----
           extinct=0.0_dp
           coef = 1.0d0!2.d-21 *sc_l* boxlen       !cm^2; Eq.34 Glover & Mac Low 2007
           
           !! Loop in theta and phi 
           do index_m=1,NdirExt_m
              do index_n=1,NdirExt_n
                 
                 ! now take the exponential and sum over directions 
                 extinct = extinct + vcolumn_dens(index_m,index_n)!exp(-vcolumn_dens(index_m,index_n)*coef) 
              end do
           end do
           coeff_chi  = extinct/(NdirExt_m*NdirExt_n)
           !G0 = G0*coeff_chi  
           
           !call calc_temp(nH(i),Temp,dt_ilev,vcolumn_dens,coeff_chi)    
           
           ! if extinction => The value of G0 has changed
           ! G0=G0*extinc/Ndirtot for i    Ndirtot=NdirExt_m*NdirExt_n
           
           uold(ind_leaf(i),firstindex_extinct+1) = coeff_chi
!print*,coeff_chi
        end if  !EXTINCTION
     end do
!NEXTINCT>0
#endif

     ! Compute metallicity in solar units
     if(metal)then
        do i=1,nleaf
           Zsolar(i)=uold(ind_leaf(i),imetal)/nH(i)/0.02
        end do
     else
        do i=1,nleaf
           Zsolar(i)=z_ave
        end do
     endif

#ifdef RT
     ! Floor density (prone to go negative with strong rad. pressure):
     do i=1,nleaf
        uold(ind_leaf(i),1) = max(uold(ind_leaf(i),1),smallr)
     end do
     ! Initialise gas momentum and velocity for photon momentum abs.:
     do i=1,nleaf
        p_gas(:,i) = uold(ind_leaf(i),2:ndim+1) * scale_d * scale_v
        u_gas(:,i) = uold(ind_leaf(i),2:ndim+1) &
                     /uold(ind_leaf(i),1) * scale_v
     end do

#if NGROUPS>0
     if(rt_isIRtrap) then  ! Gather also trapped photons for solve_cooling
        iNp=iGroups(iIR)
        do i=1,nleaf
           il=ind_leaf(i)
           rtuold(il,iNp) = rtuold(il,iNp) + uold(il,iIRtrapVar)/Np2Ep
           if(rt_smooth) &
                rtunew(il,iNp)= rtunew(il,iNp) + uold(il,iIRtrapVar)/Np2Ep
        end do
     endif

     if(rt_vc) then      ! Add/remove radiation work on gas. Eq A6 in RT15
        iNp=iGroups(iIR)
        do i=1,nleaf 
           il=ind_leaf(i)
           NIRtot = rtuold(il,iNp)
           kScIR  = kappaSc(iIR)  
           if(is_kIR_T) then                      !      k_IR depends on T
              EIR = group_egy(iIR) * ev_to_erg * NIRtot *scale_Np
              TR = max(T2_min_fix,(EIR*rt_c_cgs/c_cgs/a_r)**0.25)
              kScIR  = kappaSc(iIR)  * (TR/10d0)**2
           endif
           kScIR = kScIR*scale_d*scale_l
           flux = rtuold(il,iNp+1:iNp+ndim)
           work = scale_v/c_cgs * kScIR * sum(uold(il,2:ndim+1)*flux) &
                * Zsolar(i) * dtnew(ilevel)       ! Eq A6
           
           uold(il,ndim+2) = uold(il,ndim+2) &    ! Add work to gas energy
                + work * group_egy(iIR) &
                * ev_to_erg / scale_d / scale_v**2 / scale_l**3
           
           rtuold(il,iNp) = rtuold(il,iNp) - work !Remove from rad density
           rtuold(il,iNp) = max(rtuold(il,iNp),smallnp)
           call reduce_flux(rtuold(il,iNp+1:iNp+ndim),rtuold(il,iNp)*rt_c)
        enddo
     endif
#endif
#endif
        
     ! Compute thermal pressure
     do i=1,nleaf
        T2(i)=uold(ind_leaf(i),ndim+2)
     end do
     do i=1,nleaf
        ekk(i)=0.0d0
     end do
     do idim=1,ndim
        do i=1,nleaf
           ekk(i)=ekk(i)+0.5*uold(ind_leaf(i),idim+1)**2/nH(i)
        end do
     end do
     do i=1,nleaf
        err(i)=0.0d0
     end do
#if NENER>0
     do irad=0,nener-1
        do i=1,nleaf
           err(i)=err(i)+uold(ind_leaf(i),inener+irad)
        end do
     end do
#endif
     do i=1,nleaf
        emag(i)=0.0d0
     end do
#ifdef SOLVERmhd
     do idim=1,ndim
        do i=1,nleaf
           emag(i)=emag(i)+0.125d0*(uold(ind_leaf(i),idim+ndim+2)+uold(ind_leaf(i),idim+nvar))**2
        end do
     end do
#endif
     do i=1,nleaf
        T2(i)=(gamma-1.0)*(T2(i)-ekk(i)-err(i)-emag(i))
     end do

     ! Compute T2=T/mu in Kelvin
     do i=1,nleaf
        sum_dust =0.0d0
#if NDUST>0        
        do idust = 1, ndust
           sum_dust=sum_dust+uold(ind_leaf(i),firstindex_ndust+idust)/nH(i)
        end do
#endif    
        T2(i)=T2(i)/nH(i)/(1.0d0-sum_dust)*scale_T2

!        if(ind .eq. 1 .and. abs(xg(ind_grid(i),1)-0.5) .le. dx .and. abs(xg(ind_grid(i),2)-0.5) .le. dx) then
!           write(*,*) 'T2, nH, scale_T2',T2(i),nH(i),scale_T2
!        do ii=0,nIons-1
!            write(*,*) 'iions', ii, uold(ind_leaf(i),iIons+ii)/uold(ind_leaf(i),1)
!        end do
!        endif

     end do

     ! Compute nH in H/cc
     do i=1,nleaf
        nH(i)=nH(i)*scale_nH
     end do

     ! Compute radiation boost factor
     if(self_shielding)then
        do i=1,nleaf
           boost(i)=MAX(exp(-nH(i)/0.01),1.0D-20)
        end do
#ifdef ATON
     else if (aton) then
        do i=1,nleaf
           boost(i)=MAX(Erad(ind_leaf(i))/J0simple(aexp), &
                &                   J0min/J0simple(aexp) )
        end do
#endif
     else
        do i=1,nleaf
           boost(i)=1.0
        end do
     endif

     !==========================================
     ! Compute temperature from polytrope EOS
     !==========================================
     if(jeans_ncells>0)then
        do i=1,nleaf
           sum_dust =0.0d0
#if NDUST>0           
         do idust = 1, ndust
              sum_dust=sum_dust+uold(ind_leaf(i),firstindex_ndust+idust)/nH(i)
           end do
#endif    
           T2min(i) = nH(i)*(1.0d0-sum_dust)*polytropic_constant*scale_T2
        end do
     else
        do i=1,nleaf
           T2min(i) = 0. !T2_star*(nH(i)/nISM)**(g_star-1.0)
        end do
     endif
     !==========================================
     ! You can put your own polytrope EOS here
     !==========================================
     ! Compute temperature from polytrope
     if(isothermal)then
        ! Set to T2_star
        do i=1,nleaf
           T2min(i) = T2_star
        end do
     end if
     
     if(barotrop)then
        do i=1,nleaf
           sum_dust =0.0d0
#if NDUST>0           
           do idust = 1, ndust
              sum_dust=sum_dust+uold(ind_leaf(i),firstindex_ndust+idust)/nH(i)
           end do
#endif       
           T2min(i) = barotrop1D((1.0d0-sum_dust)*nH(i)*scale_d) 
        enddo
     end if

     if(cooling)then
        ! Compute thermal temperature by substracting polytrope
        do i=1,nleaf
           T2(i) = min(max(T2(i)-T2min(i),T2_min_fix),T2max)
        end do
     endif

     ! Compute cooling time step in second
     dtcool = dtnew(ilevel)*scale_t

#ifdef RT
     if(neq_chem) then
        ! Get the ionization fractions
        do ii=0,nIons-1
           do i=1,nleaf
              xion(1+ii,i) = uold(ind_leaf(i),iIons+ii)/uold(ind_leaf(i),1)
           end do
        end do

        ! Get photon densities and flux magnitudes
        do ig=1,nGroups
           iNp=iGroups(ig)
           do i=1,nleaf
              il=ind_leaf(i)
              Np(ig,i)        = scale_Np * rtuold(il,iNp)
              Fp(1:ndim, ig, i) = scale_Fp * rtuold(il,iNp+1:iNp+ndim)
           enddo
           if(rt_smooth) then                           ! Smooth RT update
              do i=1,nleaf !Calc addition per sec to Np, Fp for current dt
                 il=ind_leaf(i)
                 Npnew = scale_Np * rtunew(il,iNp)
                 Fpnew = scale_Fp * rtunew(il,iNp+1:iNp+ndim)
                 dNpdt(ig,i)   = (Npnew - Np(ig,i)) / dtcool
                 dFpdt(:,ig,i) = (Fpnew - Fp(:,ig,i)) / dtcool
              end do
           end if
        end do

        if(cooling .and. delayed_cooling) then
           cooling_on(1:nleaf)=.true.
           do i=1,nleaf
              if(uold(ind_leaf(i),idelay)/uold(ind_leaf(i),1) .gt. 1d-3) &
                   cooling_on(i)=.false.
           end do
        end if
        if(isothermal)cooling_on(1:nleaf)=.false.
     endif
     
     if(rt_vc) then ! Do the Lorentz boost. Eqs A4 and A5. in RT15
        do i=1,nleaf
           do ig=1,nGroups
              Npc=Np(ig,i)*rt_c_cgs
              call cmp_Eddington_tensor(Npc,Fp(:,ig,i),tEdd)
              Np_boost(ig,i) = - 2d0/c_cgs/rt_c_cgs * sum(u_gas(:,i)*Fp(:,ig,i))
              do idim=1,ndim
                 Fp_boost(idim,ig,i) =  &
                      -u_gas(idim,i)*Np(ig,i) * rt_c_cgs/c_cgs &
                      -sum(u_gas(:,i)*tEdd(idim,:))*Np(ig,i)*rt_c_cgs/c_cgs
              end do
           end do
           Np(:,i)   = Np(:,i) + Np_boost(:,i)
           Fp(:,:,i) = Fp(:,:,i) + Fp_boost(:,:,i)
        end do
     endif
#endif

     ! grackle tabular cooling
#ifdef grackle
     if(use_grackle==1)then
        gr_rank = 3
        do i = 1, gr_rank
           gr_dimension(i) = 1
           gr_start(i) = 0
           gr_end(i) = 0
        enddo
        gr_dimension(1) = nvector
        gr_end(1) = nleaf - 1
   
        if(cosmo)then
           my_grackle_units%a_value = MAX(aexp,0.0625)
           my_grackle_units%density_units = scale_d
           my_grackle_units%length_units = scale_l
           my_grackle_units%time_units = scale_t
           my_grackle_units%velocity_units = scale_v
        endif
   
        do i = 1, nleaf
           gr_density(i) = uold(ind_leaf(i),1)
           if(metal)then
              gr_metal_density(i) = uold(ind_leaf(i),imetal)
           else
              gr_metal_density(i) = uold(ind_leaf(i),1)*0.02*z_ave
           endif
           gr_energy(i) = T2(i)/(scale_T2*(gamma-1.0))
           gr_HI_density(i) = X*gr_density(i)
           gr_HeI_density(i) = (1.0-X)*gr_density(i)
           gr_DI_density(i) = 2.0*3.4e-5*gr_density(i)
        enddo
        ! Update grid properties
        my_grackle_fields%grid_rank = gr_rank
        my_grackle_fields%grid_dx = dx_loc
  
        iresult = solve_chemistry(my_grackle_units, my_grackle_fields, dtnew(ilevel))
        if(iresult.eq.0)then
            write(*,*) 'Grackle: error in solve_chemistry'
#ifndef WITHOUTMPI
            call MPI_ABORT(MPI_COMM_WORLD,1,info)
#else
            stop
#endif
        endif
   
        do i = 1, nleaf
           T2_new(i) = gr_energy(i)*scale_T2*(gamma-1.0)
        end do
        delta_T2(1:nleaf) = T2_new(1:nleaf) - T2(1:nleaf)
     else
        ! Compute net cooling at constant nH
        if(cooling.and..not.neq_chem)then
           call solve_cooling(nH,T2,Zsolar,boost,dtcool,delta_T2,nleaf)

        endif
     endif
#else
!     ! Compute net cooling at constant nH

!commented by PH to make it compatible with 'FRIG' version 19/02/2017
!     if(cooling.and..not.neq_chem)then
!        call solve_cooling(nH,T2,Zsolar,boost,dtcool,delta_T2,nleaf)
!     endif
!#endif
!#ifdef RT
!     if(neq_chem) then
!        T2_new(1:nleaf) = T2(1:nleaf)
!        call rt_solve_cooling(T2_new, xion, Np, Fp, p_gas, dNpdt, dFpdt  &
!                         , nH, cooling_on, Zsolar, dtcool, aexp_loc,nleaf)
!        delta_T2(1:nleaf) = T2_new(1:nleaf) - T2(1:nleaf)
!     endif
!#endif
!end of commented by PH

     if(cooling.and..not.neq_chem)then
!        call solve_cooling(nH,T2,Zsolar,boost,dtcool,delta_T2,nleaf)
! USE Audit & Hennebelle cooling function
        call solve_cooling_frig(nH,T2,Zsolar,boost,dtcool,delta_T2,nleaf)

!           write(*,*) 'solve cooling no RT'
     endif
#endif
#ifdef RT
     if(neq_chem) then
        T2_new(1:nleaf) = T2(1:nleaf)
        if(sinks_opt_thin)then
           do i=1,nleaf!!!raph 28/04/2020 for sink opt thin
              insink(i)=in_sink(ind_leaf(i))
           enddo
        endif
        call rt_solve_cooling(T2_new, xion, Np, Fp, p_gas, dNpdt, dFpdt  &
                         , nH, cooling_on, Zsolar, dtcool, aexp_loc,nleaf,insink)
        delta_T2(1:nleaf) = T2_new(1:nleaf) - T2(1:nleaf)

!     do i=1,nleaf
!        if(ind .eq. 1 .and. abs(xg(ind_grid(i),1)-0.5) .le. dx .and. abs(xg(ind_grid(i),2)-0.5) .le. dx) then
!           write(*,*) 'a T2, nH, scale_T2',T2(i),nH(i),scale_T2
!           write(*,*) 'a T2new, nH, scale_T2',T2_new(i),nH(i),scale_T2
!        endif
!     end do

     endif
#endif





#ifdef RT
     if(.not. static) then
        ! Update gas momentum and kinetic energy:
        do i=1,nleaf
           uold(ind_leaf(i),2:1+ndim) = p_gas(:,i) /scale_d /scale_v
        end do
        ! Energy update ==================================================
        ! Calculate NEW pressure from updated momentum
        ekk_new(1:nleaf) = 0d0
        do i=1,nleaf
           do idim=1,ndim
              ekk_new(i) = ekk_new(i) &
                   + 0.5*uold(ind_leaf(i),idim+1)**2 / uold(ind_leaf(i),1)
           end do
        end do
        do i=1,nleaf                                   
           ! Update the pressure variable with the new kinetic energy:
           uold(ind_leaf(i),ndim+2) = uold(ind_leaf(i),ndim+2)           &
                                    - ekk(i) + ekk_new(i)
        end do
        do i=1,nleaf                                   
           ekk(i)=ekk_new(i)
        end do
     
#if NGROUPS>0 
        if(rt_vc) then ! Photon work: subtract from the IR ONLY radiation
           do i=1,nleaf                                   
              Np(iIR,i) = Np(iIR,i) + (ekk(i) - ekk_new(i))              &
                   /scale_d/scale_v**2 / group_egy(iIR) / ev_to_erg
           end do
        endif
#endif
        ! End energy update ==============================================
     endif ! if(.not. static)
#endif

     ! Compute rho
     do i=1,nleaf
        nH(i) = nH(i)/scale_nH
     end do

     ! Deal with cooling
     if(cooling.or.neq_chem)then
        ! Compute net energy sink
        do i=1,nleaf
           sum_dust=0.0d0
#if NDUST>0        
           do idust = 1, ndust
              sum_dust=sum_dust+uold(ind_leaf(i),firstindex_ndust+idust)/uold(ind_leaf(i),1)
           end do
#endif  
           delta_T2(i) = delta_T2(i)*(1.0d0-sum_dust)*nH(i)/scale_T2/(gamma-1.0)
        end do
        ! Compute initial fluid internal energy
        do i=1,nleaf
           sum_dust=0.0d0
#if NDUST>0        
         do idust = 1, ndust
              sum_dust=sum_dust+uold(ind_leaf(i),firstindex_ndust+idust)/uold(ind_leaf(i),1)
           end do
#endif  
           T2(i) = T2(i)*nH(i)*(1.0d0-sum_dust)/scale_T2/(gamma-1.0)
        end do
        ! Turn off cooling in blast wave regions
        if(delayed_cooling)then
           do i=1,nleaf
              cooling_switch = uold(ind_leaf(i),idelay)/max(uold(ind_leaf(i),1),smallr)
              if(cooling_switch > 1d-3)then
                 delta_T2(i) = MAX(delta_T2(i),real(0,kind=dp))
              endif
           end do
        endif
     endif

     ! Compute polytrope internal energy
     do i=1,nleaf
        sum_dust=0.0d0
#if NDUST>0        
        do idust = 1, ndust
           sum_dust=sum_dust+uold(ind_leaf(i),firstindex_ndust+idust)/uold(ind_leaf(i),1)
        end do
#endif  
        T2min(i) = T2min(i)*(1.0d0-sum_dust)*nH(i)/scale_T2/(gamma-1.0)
     end do

     ! Update fluid internal energy
     if(cooling.or.neq_chem)then
        do i=1,nleaf
           T2(i) = T2(i) + delta_T2(i)
        end do
     endif

     ! Update total fluid energy
     if(isothermal)then
        do i=1,nleaf
           uold(ind_leaf(i),ndim+2) = T2min(i) + ekk(i) + err(i) + emag(i)
        end do
     else if((cooling .or. neq_chem) .and. .not.fld)then
        do i=1,nleaf
           uold(ind_leaf(i),ndim+2) = T2(i) + T2min(i) + ekk(i) + err(i) + emag(i)
        end do
     endif

     ! Update delayed cooling switch
     if(delayed_cooling)then
        t_blast=t_diss*1d6*(365.*24.*3600.)
        damp_factor=exp(-dtcool/t_blast)
        do i=1,nleaf
           uold(ind_leaf(i),idelay)=uold(ind_leaf(i),idelay)*damp_factor
        end do
     endif

#ifdef RT
     if(neq_chem) then
        ! Update ionization fraction
        do ii=0,nIons-1
           do i=1,nleaf
              uold(ind_leaf(i),iIons+ii) = xion(1+ii,i)*nH(i)
           end do
        end do
     endif
#if NGROUPS>0 
     if(rt) then
        ! Update photon densities and flux magnitudes
        do ig=1,nGroups
           do i=1,nleaf
              rtuold(ind_leaf(i),iGroups(ig)) = (Np(ig,i)-Np_boost(ig,i)) /scale_Np
              rtuold(ind_leaf(i),iGroups(ig)) = &
                   max(rtuold(ind_leaf(i),iGroups(ig)),smallNp)
              rtuold(ind_leaf(i),iGroups(ig)+1:iGroups(ig)+ndim)         &
                               = (Fp(1:ndim,ig,i)-Fp_boost(1:ndim,ig,i)) /scale_Fp
           enddo
        end do
     endif

     ! Split IR photons into trapped and freeflowing
     if(rt_isIRtrap) then
        if(nener .le. 0) then
           print*,'Trying to store E_trapped pressure, but NERAD too small!!'
           STOP
        endif
        iNp=iGroups(iIR)
        unit_tau = 1.5d0 * dx_loc * scale_d * scale_l
        do i=1,nleaf                                                    
           il=ind_leaf(i)                                               
           NIRtot =max(rtuold(il,iNp),smallNp)      ! Total photon density
           kScIR  = kappaSc(iIR)                                          
           if(is_kIR_T) then                        !    k_IR depends on T
              EIR = group_egy(iIR) * ev_to_erg * NIRtot *scale_Np  
              TR = max(T2_min_fix,(EIR*rt_c_cgs/c_cgs/a_r)**0.25)
              kScIR  = kappaSc(iIR) * (TR/10d0)**2               
           endif                                                        
           tau = nH(i) * Zsolar(i) * unit_tau * kScIR                  
           f_trap = 0d0             ! Fraction IR photons that are trapped
           if(tau .gt. 0d0) f_trap = min(max(exp(-1d0/tau), 0d0), 1d0) 
           ! Update streaming photons, trapped photons, and tot energy:
           rtuold(il,iNp) = max(smallnp,(1d0-f_trap) * NIRtot) ! Streaming
           rtuold(il,iNp+1:iNp+ndim) = &            ! Limit streaming flux
                                  rtuold(il,iNp+1:iNp+ndim) * (1d0-f_trap)
           EIR_trapped = max(0d0, NIRtot-rtuold(il,iNp)) * Np2Ep ! Trapped
           ! Update tot energy due to change in trapped radiation energy:
           uold(il,ndim+2)=uold(il,ndim+2)-uold(il,iIRtrapVar)+EIR_trapped
           ! Update the trapped photon energy:
           uold(il,iIRtrapVar) = EIR_trapped

           call reduce_flux(rtuold(il,iNp+1:iNp+ndim),rtuold(il,iNp)*rt_c)
        end do ! i=1,nleaf                                                 

     endif  !rt_isIRtrap     
#endif
#endif
     if(barotrop)then
        do i=1,nleaf
           uold(ind_leaf(i),2+ndim) = T2min(i) + ekk(i) + err(i) + emag(i)
           uold(ind_leaf(i),nvar  ) = T2min(i)
        end do
     end if


  end do
  ! End loop over cells

end subroutine coolfine1

#ifdef RT
!************************************************************************
subroutine cmp_Eddington_tensor(Npc,Fp,T_Edd)
  
! Compute Eddington tensor for given radiation variables
! Npc     => Photon number density times light speed
! Fp     => Photon number flux
! T_Edd  <= Returned Eddington tensor
!------------------------------------------------------------------------
  use amr_commons
  implicit none
  real(dp)::Npc
  real(dp),dimension(1:ndim)::Fp ,u
  real(dp),dimension(1:ndim,1:ndim)::T_Edd 
  real(dp)::iterm,oterm,Np_c_sq,Fp_sq,fred_sq,chi
  integer::p,q
!------------------------------------------------------------------------
  if(Npc .le. 0.d0) then
     write(*,*)'negative photon density in cmp_Eddington_tensor. -EXITING-'
     call clean_stop
  endif
  T_Edd(:,:) = 0.d0   
  Np_c_sq = Npc**2        
  Fp_sq = sum(Fp**2)              !  Sq. photon flux magnitude
  u(:) = 0.d0                           !           Flux unit vector
  if(Fp_sq .gt. 0.d0) u(:) = Fp/sqrt(Fp_sq)  
  fred_sq = Fp_sq/Np_c_sq           !      Reduced flux, squared
  chi = max(4.d0-3.d0*fred_sq, 0.d0)   !           Eddington factor
  chi = (3.d0+ 4.d0*fred_sq)/(5.d0 + 2.d0*sqrt(chi))
  iterm = (1.d0-chi)/2.d0               !    Identity term in tensor
  oterm = (3.d0*chi-1.d0)/2.d0          !         Outer product term
  do p = 1, ndim
     do q = 1, ndim
        T_Edd(p,q) = oterm * u(p) * u(q)
     enddo
     T_Edd(p,p) = T_Edd(p,p) + iterm
  enddo
  
end subroutine cmp_Eddington_tensor
#endif
!==================================================================================
!==================================================================================
!==================================================================================
!==================================================================================
!=====================================================================================================
!=====================================================================================================
!=====================================================================================================
!=====================================================================================================
subroutine pressure_eos(rho_temp,Enint_temp,Peos)
  use amr_commons
  use hydro_commons
  use units_commons
  use cooling_module      ,only:kB,mH
  use radiation_parameters,only:mu_gas

  implicit none
  !--------------------------------------------------------------
  ! This routine computes the pressure from the density and 
  ! internal volumic energy. Inputs/output are in code units
  !--------------------------------------------------------------
  integer::i_t,i_r,i
  real(dp), intent(in) :: Enint_temp,rho_temp
  real(dp):: Enint,rho
  real(dp), intent(out):: Peos
  real(dp)::logr,tt,uu,y1,y2,y3,y4
  real(dp):: le,lr
  real(dp):: dd1,dd2,de1,de2
  integer :: ir,ie
  real(dp):: xx,drho,dener

  if(eos)then
  rho = rho_temp * scale_d
  Enint   = Enint_temp * scale_d*scale_v**2 
  
  drho  = (rhomax-rhomin)/float(nRho)
  lr = 0.5d0 + (log10(rho )- rhomin )/drho

  if (lr .ge. Nrho) then
     write(*,*)'intermaxrho',rho ,rho_eos(nRho,1)
     stop
  endif
  ir = floor(lr)

  dEner = ( Emax  -   emin)/float(nEnergy)
  le = 0.5d0 + (log10(Enint) - emin - log10(rho) )/dEner

  if ((le .ge. nEnergy) ) then
     write(*,*)'intermaxE_P',Enint ,Ener_eos(ir,nEnergy)
     stop
  endif

  ie = floor(le)
  if  (ir < 1 .or. ie < 1 .or. ir>nrho .or. ie>nEnergy) then
     write(*,*) 'inter_pressure hors limite i,ir,ie = ',ir,ie,rho ,Enint 
     ir=1.0d0
     ie=1.0d0
     stop
  endif

  dd1 = lr - float(ir)
  dd2 = le - float(ie)

  de1 = 1.0d0 - dd1
  de2 = 1.0d0 - dd2

  Peos=0.d0

  Peos = Peos + de1*de2*P_eos(ir  ,ie  )
  Peos = Peos + dd1*de2*P_eos(ir+1,ie  )
  Peos = Peos + de1*dd2*P_eos(ir  ,ie+1)
  Peos = Peos + dd1*dd2*P_eos(ir+1,ie+1)

  Peos = Peos / (scale_d *scale_v**2) ! give P in code units

  xx =  P_eos(ir,ie)*P_eos(ir+1,ie)*P_eos(ir,ie+1)*P_eos(ir+1,ie+1) 

  if (xx .eq. 0.0d0 ) then
     write(*,*) '**************** P_eos ****************'
     write(*,*) 'ir,ie,i =',ir,ie,i
     write(*,*) rho ,Enint 
     write(*,*) P_eos(ir,ie  ), P_eos(ir+1,ie  ) 
     write(*,*) P_eos(ir,ie+1), P_eos(ir+1,ie+1)
     write(*,*) P_eos(ir,ie+2), P_eos(ir-1,ie+1)
     write(*,*) 0.25*(P_eos(ir,ie+2) + P_eos(ir-1,ie+1) +   P_eos(ir+1,ie+1) +  P_eos(ir,ie))
     stop
  endif
else
     Peos = (gamma-1.d0)*Enint_temp
end if
end subroutine pressure_eos
!===========================================================================================
!===========================================================================================
!===========================================================================================
!===========================================================================================
subroutine temperature_eos(rho_temp,Enint_temp,Teos,ht)
  use amr_commons
  use hydro_commons
  use units_commons
  use cooling_module      ,only:kB,mH
  use radiation_parameters,only:mu_gas
  implicit none
  !--------------------------------------------------------------
  ! This routine computes the temperature from the density and 
  ! internal volumic energy. Inputs/output are in code units.
  !--------------------------------------------------------------
  integer::i_t,i_r,i
  integer::ht
  real(dp), intent(in) :: Enint_temp,rho_temp
  real(dp):: Enint,rho
  real(dp), intent(out):: Teos
  real(dp)::logr,tt,uu,y1,y2,y3,y4
  real(dp):: le,lr
  real(dp):: dd1,dd2,de1,de2
  integer :: ir,ie
  real(dp):: xx,drho,dener
  real(dp) :: barotrop1D

if(eos)then
  if (enint_temp ==0.d0) then
     teos=0.d0
  else
     ht=0

     rho   = rho_temp * scale_d             
     Enint = Enint_temp * scale_d*scale_v**2

     drho  = (rhomax-rhomin)/float(nRho)
     lr = 0.5d0 + (log10(rho )- rhomin )/drho

     if (lr .ge. Nrho) then
        write(*,*)'pb 1'
        stop
     endif
     ir = floor(lr)

     dEner = ( Emax  -   emin)/float(nEnergy)
     le = 0.5d0 + (log10(Enint) - emin - log10(rho) )/dEner

     if ((le .ge. nEnergy) ) then
        write(*,*)'pb 2'
        stop
     endif

     ie = floor(le)
     if  (ir < 1 .or. ie < 1 ) then
        write(*,*) 'inter_tp hors limite ir,ie,rho,enint = ',ir,ie,rho ,Enint 
        ir=1.0d0
        ie=1.0d0
        stop
     endif

     dd1 = lr - float(ir)
     dd2 = le - float(ie)

     de1 = 1.0d0 - dd1
     de2 = 1.0d0 - dd2

     Teos=0.d0

     Teos = Teos + de1*de2*Temp_eos(ir  ,ie  )
     Teos = Teos + dd1*de2*Temp_eos(ir+1,ie  )
     Teos = Teos + de1*dd2*Temp_eos(ir  ,ie+1)
     Teos = Teos + dd1*dd2*Temp_eos(ir+1,ie+1)

     Teos = Teos ! give T in K

     xx =  Temp_eos(ir,ie)*Temp_eos(ir+1,ie)*Temp_eos(ir,ie+1)*Temp_eos(ir+1,ie+1) 

     if (xx .eq. 0.0d0 ) then
        ht=1
        !     write(*,*) '**************** Pb_eos ****************'
        !     write(*,*) 'ir,ie,i =',ir,ie,i
        !     write(*,*) rho ,Enint 
        !     write(*,*) Temp_eos(ir,ie  ), Temp_eos(ir+1,ie  ) 
        !     write(*,*) Temp_eos(ir,ie+1), Temp_eos(ir+1,ie+1)
        !     write(*,*) Temp_eos(ir,ie+2), Temp_eos(ir-1,ie+1)
        !     write(*,*) 0.25*(Temp_eos(ir,ie+2) + Temp_eos(ir-1,ie+1) +   Temp_eos(ir+1,ie+1) +  Temp_eos(ir,ie))
        !     stop
     endif
  endif
  else if(barotrop)then
     Teos=barotrop1D(rho_temp*scale_d)
  else 
     rho   = rho_temp*scale_d
     Enint = Enint_temp*scale_d*scale_v**2 

     Teos = Enint/(rho*kB/(mu_gas*mH*(gamma-1.0d0)))
     
     ht=1
  end if

end subroutine temperature_eos
!===========================================================================================
!===========================================================================================
!===========================================================================================
!===========================================================================================
subroutine enerint_eos(rho_temp,temp_temp,Eeos)
  use amr_commons
  use hydro_commons
  use units_commons
  use cooling_module      ,only:kB,mH
  use radiation_parameters,only:mu_gas
  implicit none
  !--------------------------------------------------------------
  ! This routine computes the internal volumic energy from  
  ! the density and the temperature. Inputs/output are in code units.
  !--------------------------------------------------------------
  integer::i_t,i_r,i
  real(dp), intent(in) :: temp_temp,rho_temp
  real(dp):: temp,rho
  real(dp), intent(out):: Eeos
  real(dp)::logr,tt,uu,y1,y2,y3,y4
  real(dp):: le,lr
  real(dp):: dd1,dd2,de1,de2
  integer :: ir,ie
  real(dp):: xx,drho,dtemp

  if(eos)then
     rho = rho_temp * scale_d
     temp   = temp_temp
     
     drho  = (rhomax-rhomin)/float(nRho)
     lr = 0.5d0 + (log10(rho )- rhomin )/drho

  if (lr .ge. Nrho) then
     write(*,*)'pb 11'
     stop
  endif
  ir = floor(lr)

  dtemp = ( log10(Tmax)  -   log10(Tmin))/float(ntemp)
  le = 1.0d0 + (log10(temp) - log10(Tmin))/dtemp

  if ((le .ge. ntemp) ) then
     write(*,*)'pb 22'
     stop
  endif

  ie = floor(le)
  if  (ir < 1 .or. ie < 1 ) then
     write(*,*) 'inter_ener hors limite ir,ie,rho,enint cooling= ',ir,ie,rho ,temp
     ir=1.0d0
     ie=1.0d0
     stop
  endif


  dd1 = lr - float(ir)
  dd2 = le - float(ie)

  de1 = 1.0d0 - dd1
  de2 = 1.0d0 - dd2

  Eeos=0.d0

  Eeos = Eeos + de1*de2*eint_eos(ir  ,ie  )
  Eeos = Eeos + dd1*de2*eint_eos(ir+1,ie  )
  Eeos = Eeos + de1*dd2*eint_eos(ir  ,ie+1)
  Eeos = Eeos + dd1*dd2*eint_eos(ir+1,ie+1)

  Eeos = Eeos / (scale_d*scale_v**2) ! give energy in code units

  xx =  eint_eos(ir,ie)*eint_eos(ir+1,ie)*eint_eos(ir,ie+1)*eint_eos(ir+1,ie+1) 

  if (xx .eq. 0.0d0 ) then
     !     write(*,*) '**************** Pb_eos ****************'
     !     write(*,*) 'ir,ie,i =',ir,ie,i
     !     write(*,*) rho ,Enint 
     !     write(*,*) eint_eos(ir,ie  ), eint_eos(ir+1,ie  ) 
     !     write(*,*) eint_eos(ir,ie+1), eint_eos(ir+1,ie+1)
     !     write(*,*) eint_eos(ir,ie+2), eint_eos(ir-1,ie+1)
     !     write(*,*) 0.25*(eint_eos(ir,ie+2) + eint_eos(ir-1,ie+1) +   eint_eos(ir+1,ie+1) +  eint_eos(ir,ie))
     !     stop
  endif

else
  rho  = rho_temp * scale_d
  temp = temp_temp

  Eeos = rho*kB/(mu_gas*mH*(gamma-1.0))*temp/(scale_d*scale_v**2)
end if

end subroutine enerint_eos
!==================================================================================
!==================================================================================
!==================================================================================
!==================================================================================
subroutine soundspeed_eos(rho_temp,Enint_temp,Cseos)
  use amr_commons
  use hydro_commons
  use units_commons
  use cooling_module      ,only:kB,mH
  use radiation_parameters,only:mu_gas
  implicit none
  !--------------------------------------------------------------
  ! This routine computes the sound speed from the internal volumic energy 
  ! and the temperature. Inputs/output are in code units.
  !--------------------------------------------------------------
  integer::i_t,i_r,i
  real(dp), intent(in) :: Enint_temp,rho_temp
  real(dp):: Enint,rho
  real(dp), intent(out):: Cseos
  real(dp)::logr,tt,uu,y1,y2,y3,y4
  real(dp):: le,lr
  real(dp):: dd1,dd2,de1,de2
  integer :: ir,ie
  real(dp):: xx,drho,dener

if(eos)then
   rho = rho_temp * scale_d
  Enint   = Enint_temp * scale_d*scale_v**2

  drho  = (rhomax-rhomin)/float(nRho)
  lr = 0.50d0 + (log10(rho )- rhomin )/drho

  if (lr .ge. Nrho) then
     write(*,*)'intermaxrho',rho ,rho_eos(nRho,1)
     stop
  endif
  ir = floor(lr)

  dEner = ( Emax  -   emin)/float(nEnergy)
  le = 0.50d0 + (log10(Enint) - emin - log10(rho) )/dEner

  if ((le .ge. nEnergy) ) then
     write(*,*)'intermaxE_s',Enint ,Ener_eos(ir,nEnergy)
     stop
  endif

  ie = floor(le)
  if  (ir < 1 .or. ie < 1 ) then
     write(*,*) 'inter_Cs hors limite i,ir,ie = ',ir,ie,rho ,Enint, myid
     ir=1.0d0
     ie=1.0d0
     stop
  endif

  dd1 = lr - float(ir)
  dd2 = le - float(ie)

  de1 = 1.0d0 - dd1
  de2 = 1.0d0 - dd2

  Cseos=0.d0


  Cseos = Cseos + de1*de2*Cs_eos(ir  ,ie  )
  Cseos = Cseos + dd1*de2*Cs_eos(ir+1,ie  )
  Cseos = Cseos + de1*dd2*Cs_eos(ir  ,ie+1)
  Cseos = Cseos + dd1*dd2*Cs_eos(ir+1,ie+1)

  Cseos = Cseos /scale_v ! give Cs in code units

  xx =  Cs_eos(ir,ie)*Cs_eos(ir+1,ie)*Cs_eos(ir,ie+1)*Cs_eos(ir+1,ie+1) 

  if (xx .eq. 0.0d0 ) then
     write(*,*) '**************** Cs_eos ****************'
     write(*,*) 'ir,ie,i =',ir,ie,i
     write(*,*) rho ,Enint 
     write(*,*) Cs_eos(ir,ie  ), Cs_eos(ir+1,ie  ) 
     write(*,*) Cs_eos(ir,ie+1), Cs_eos(ir+1,ie+1)
     write(*,*) Cs_eos(ir,ie+2), Cs_eos(ir-1,ie+1)
     write(*,*) 0.25*(Cs_eos(ir,ie+2) + Cs_eos(ir-1,ie+1) +   Cs_eos(ir+1,ie+1) +  Cs_eos(ir,ie))
     stop
  endif
else
  Cseos = sqrt(gamma*(gamma-1.d0)*Enint_temp/rho_temp)
end if
end subroutine soundspeed_eos
!################################################################
!################################################################
!################################################################
!################################################################
function cmp_Cv_eos(rho,Enint)
  use amr_commons
  use hydro_commons
  use cooling_module,only: mh,kb
  implicit none
  !--------------------------------------------------------------
  ! This routine computes Cv using
  ! the eos calculated by Chabrier & Saumon, as a function
  ! of density and internal energy
  ! Units are supposed to be in cgs here (as in units.f90)
  !--------------------------------------------------------------

  real(dp)   :: rho,Enint,xx
  real(dp)   :: drho,dener
  real(dp)   :: dd1,dd2,de1,de2
  real(dp)   :: lr,le
  real(dp)   :: cmp_Cv_eos
  integer    :: ir,ie,i

  drho  = (rhomax-rhomin)/float(nRho)
  lr = 0.5d0 + (log10(rho )- rhomin )/drho

  if (lr .ge. Nrho) then
     write(*,*)'intermaxrho',rho ,rho_eos(nRho,1)
     stop
  endif
  ir = floor(lr)

  dEner = ( Emax  -   emin)/float(nEnergy)
  le = 0.5d0 + (log10(Enint) - emin - log10(rho) )/dEner

  if ((le .ge. nEnergy) ) then
     write(*,*)'intermaxE2',Enint ,Ener_eos(ir,nEnergy)
     stop
  endif

  ie = floor(le)
  if  (ir < 1 .or. ie < 1 ) then
!!       write(*,*) 'inter_cv hors limite i,ir,ie = ',ir,ie,rho ,Enint
     ir=1.0d0
     ie=1.0d0
     !      stop
  endif

  dd1 = lr - float(ir)
  dd2 = le - float(ie)

  de1 = 1.0d0 - dd1
  de2 = 1.0d0 - dd2

  cmp_Cv_eos=0.d0

  cmp_Cv_eos = cmp_Cv_eos + de1*de2*Cv_eos(ir  ,ie  )
  cmp_Cv_eos = cmp_Cv_eos + dd1*de2*Cv_eos(ir+1,ie  )
  cmp_Cv_eos = cmp_Cv_eos + de1*dd2*Cv_eos(ir  ,ie+1)
  cmp_Cv_eos = cmp_Cv_eos + dd1*dd2*Cv_eos(ir+1,ie+1)

  cmp_Cv_eos = cmp_Cv_eos

  xx =  Cv_eos(ir,ie)*Cv_eos(ir+1,ie)*Cv_eos(ir,ie+1)*Cv_eos(ir+1,ie+1)

  if (xx .eq. 0.0d0 ) then
     write(*,*) '**************** Pb_eos ****************'
     write(*,*) 'ir,ie,i =',ir,ie,i
     write(*,*) rho ,Enint
     write(*,*) Cv_eos(ir,ie  ), Cv_eos(ir+1,ie  )
     write(*,*) Cv_eos(ir,ie+1), Cv_eos(ir+1,ie+1)
     write(*,*) Cv_eos(ir,ie+2), Cv_eos(ir-1,ie+1)
     write(*,*) 0.25*(Cv_eos(ir,ie+2) + Cv_eos(ir-1,ie+1) +   Cv_eos(ir+1,ie+1) +  Cv_eos(ir,ie))
     stop
  endif

end function cmp_Cv_eos
!################################################################
!################################################################
!################################################################
!################################################################
double precision function barotrop1D(rhon)
  use hydro_commons
  use amr_parameters, only : n_star
  use radiation_parameters, only : Tr_floor
  implicit none

  real(dp)::inp,ll,rhon
  integer :: j

  if(analytical_barotrop)then
     barotrop1D = Tr_floor * ( 1.0d0 + (rhon/n_star)**(gamma-1.0d0) )
  else
     inp=rhon ! in g.cc
     ll=(1.d0+(log10(inp)-rhomin_barotrop)/drho_barotrop)
     j=dble(floor(ll))
     barotrop1D=(ll-j)*(temp_barotrop(j+1))+(1.d0-(ll-j))*(temp_barotrop(j))
     barotrop1D=10.0d0**barotrop1D     ! temperature in K
  endif

end function barotrop1D
../patch/collapse/radiation_boundary.f90
!################################################################
!################################################################
!################################################################ 
!################################################################
subroutine make_boundary_diffusion(ilevel,igroup)
  use amr_commons
  use hydro_commons
  use cooling_module,ONLY:kB,mH,clight
  use radiation_parameters
  use units_commons
  implicit none
  ! -------------------------------------------------------------------
  ! This routine set up boundary conditions for fine levels.
  ! -------------------------------------------------------------------
  integer,intent(IN)::ilevel,igroup
  integer::ibound,boundary_dir,idim,inbor
  integer::i,ncache,ivar,igrid,ngrid,ind,ht
  integer::iskip,iskip_ref,nx_loc,ix,iy,iz,igrp
  integer,dimension(1:8)::ind_ref
  integer,dimension(1:nvector),save::ind_grid,ind_grid_ref
  integer,dimension(1:nvector),save::ind_cell,ind_cell_ref

  real(dp)::dx,dx_loc,scale
  real(dp)::rosseland_ana
  real(dp),dimension(1:3)::skip_loc
  real(dp),dimension(1:twotondim,1:3)::xc
  real(dp),dimension(1:nvector,1:ndim),save::xx
  real(dp),dimension(1:nvector,1:nvar+3),save::uu
  real(dp)::dd,t2,t2r,cal_Teg,usquare,emag,erad_loc,eps,ekin,Cv,rho

  real(dp):: sum_dust
#if NDUST>0
  integer :: idust
#endif  
  if(.not. simple_boundary)return

  ! Mesh size at level ilevel
  dx=0.5D0**ilevel

  ! Rescaling factors
  nx_loc=(icoarse_max-icoarse_min+1)
  skip_loc=(/0.0d0,0.0d0,0.0d0/)
  if(ndim>0)skip_loc(1)=dble(icoarse_min)
  if(ndim>1)skip_loc(2)=dble(jcoarse_min)
  if(ndim>2)skip_loc(3)=dble(kcoarse_min)
  scale=boxlen/dble(nx_loc)
  dx_loc=dx*scale

  ! Set position of cell centers relative to grid center
  do ind=1,twotondim
     iz=(ind-1)/4
     iy=(ind-1-4*iz)/2
     ix=(ind-1-2*iy-4*iz)
     if(ndim>0)xc(ind,1)=(dble(ix)-0.5D0)*dx
     if(ndim>1)xc(ind,2)=(dble(iy)-0.5D0)*dx
     if(ndim>2)xc(ind,3)=(dble(iz)-0.5D0)*dx
  end do

  ! Loop over boundaries
  do ibound=1,nboundary
     ! Compute direction of reference neighbors
     boundary_dir=boundary_type(ibound)-10*(boundary_type(ibound)/10)
     if(boundary_dir==1)inbor=2

     if(boundary_dir==2)inbor=1
     if(boundary_dir==3)inbor=4
     if(boundary_dir==4)inbor=3
     if(boundary_dir==5)inbor=6
     if(boundary_dir==6)inbor=5

     ! Compute index of reference cells
     ! Zero flux
     if(boundary_type(ibound)== 1)ind_ref(1:8)=(/2,1,4,3,6,5,8,7/)
     if(boundary_type(ibound)== 2)ind_ref(1:8)=(/2,1,4,3,6,5,8,7/)
     if(boundary_type(ibound)== 3)ind_ref(1:8)=(/3,4,1,2,7,8,5,6/)
     if(boundary_type(ibound)== 4)ind_ref(1:8)=(/3,4,1,2,7,8,5,6/)
     if(boundary_type(ibound)== 5)ind_ref(1:8)=(/5,6,7,8,1,2,3,4/)
     if(boundary_type(ibound)== 6)ind_ref(1:8)=(/5,6,7,8,1,2,3,4/)
     ! Zero flux
     if(boundary_type(ibound)==11)ind_ref(1:8)=(/1,1,3,3,5,5,7,7/)
     if(boundary_type(ibound)==12)ind_ref(1:8)=(/2,2,4,4,6,6,8,8/)
     if(boundary_type(ibound)==13)ind_ref(1:8)=(/1,2,1,2,5,6,5,6/)
     if(boundary_type(ibound)==14)ind_ref(1:8)=(/3,4,3,4,7,8,7,8/)
     if(boundary_type(ibound)==15)ind_ref(1:8)=(/1,2,3,4,1,2,3,4/)
     if(boundary_type(ibound)==16)ind_ref(1:8)=(/5,6,7,8,5,6,7,8/)
     ! Imposed boundary
     if(boundary_type(ibound)==21)ind_ref(1:8)=(/1,1,3,3,5,5,7,7/)
     if(boundary_type(ibound)==22)ind_ref(1:8)=(/2,2,4,4,6,6,8,8/)
     if(boundary_type(ibound)==23)ind_ref(1:8)=(/1,2,1,2,5,6,5,6/)
     if(boundary_type(ibound)==24)ind_ref(1:8)=(/3,4,3,4,7,8,7,8/)
     if(boundary_type(ibound)==25)ind_ref(1:8)=(/1,2,3,4,1,2,3,4/)
     if(boundary_type(ibound)==26)ind_ref(1:8)=(/5,6,7,8,5,6,7,8/)

     ! Loop over grids by vector sweeps
     ncache=boundary(ibound,ilevel)%ngrid
     do igrid=1,ncache,nvector
        ngrid=MIN(nvector,ncache-igrid+1)
        do i=1,ngrid
           ind_grid(i)=boundary(ibound,ilevel)%igrid(igrid+i-1)
        end do

        ! Gather neighboring reference grid
        do i=1,ngrid
           ind_grid_ref(i)=son(nbor(ind_grid(i),inbor))
        end do

        ! Loop over cells
        do ind=1,twotondim
           iskip=ncoarse+(ind-1)*ngridmax
           do i=1,ngrid
              ind_cell(i)=iskip+ind_grid(i)
           end do

           ! Gather neighboring reference cell
           iskip_ref=ncoarse+(ind_ref(ind)-1)*ngridmax
           do i=1,ngrid
              ind_cell_ref(i)=iskip_ref+ind_grid_ref(i)
           end do

!!            ! Zero flux boundary conditions
!!            if((boundary_type(ibound)/10).ne.2)then
!! 
!!               ! Gather reference variables and  scatter to boundary region
!!               do i=1,ngrid
!!                  if(son(ind_cell(i)) == 0)then
!!                     uold(ind_cell(i),8+igroup)  = uold(ind_cell_ref(i),8+igroup)
!!                     unew(ind_cell(i),8+igroup)  = unew(ind_cell_ref(i),8+igroup)
!!                     unew(ind_cell(i),5)     = unew(ind_cell_ref(i),5)
!!                     unew(ind_cell(i),nvar+3)= unew(ind_cell_ref(i),5)
!!                     enew(ind_cell(i))       = unew(ind_cell_ref(i),8+igroup)
!!                     divu(ind_cell(i))       = divu(ind_cell_ref(i))
!!                     unew(ind_cell(i),2)     = unew(ind_cell_ref(i),2)
!!                  end if
!!               end do
!! 
!!               ! Imposed boundary conditions
!!            else

              ! Compute cell center in code units and rescale position from code units to user units
              do idim=1,ndim
                 do i=1,ngrid
                    if(son(ind_cell(i)) == 0)then
                       xx(i,idim)=(xg(ind_grid(i),idim)+xc(ind,idim)-skip_loc(idim))*scale
                    end if
                 end do
              end do
              
              call boundana(xx,uu,dx_loc,ibound,ngrid)
              
              ! Scatter variables
              do i=1,ngrid 
                 if(son(ind_cell(i)) == 0)then
                    dd=max(uu(i,1),smallr)
                    
                    usquare=0.0_dp
                    do idim=1,ndim
                       usquare=usquare+(uu(i,idim+1)/uu(i,1))**2
                    end do
                    ! Compute total magnetic energy
                    emag = 0.0_dp
                    do ivar=1,3
                       emag = emag + 0.125_dp*(uu(i,5+ivar) + uu(i,nvar+ivar))**2
                    end do
                    ! Compute total non-thermal+radiative energy
                    erad_loc=0.0_dp
                    do igrp=1,nener
                       erad_loc=erad_loc+uu(i,8+igrp)
                    enddo

                    rho   = uu(i,1)
                    ekin  = rho*usquare*0.5_dp
                    eps   = (uu(i,5)-ekin-emag-erad_loc)
                    sum_dust =0.0_dp
#if NDUST>0
                    do idust = 1, ndust
                       sum_dust = sum_dust + uu(i,firstindex_ndust+idust)/rho
                    end do
#endif 
                    call temperature_eos((1.0_dp-sum_dust)*rho,eps,t2,ht)
                    t2    = Tr_floor ! comment this for radiative shock

                    unew(ind_cell(i),nvar+3) = t2
                    unew(ind_cell(i),5)      = t2
                    
                    uold(ind_cell(i),firstindex_er+igroup)= uu(i,firstindex_er+igroup)*scale_d*scale_v**2/(scale_E0)
                    unew(ind_cell(i),firstindex_er+igroup)= uold(ind_cell(i),firstindex_er+igroup)
                    enew(ind_cell(i)         )= uold(ind_cell(i),firstindex_er+igroup)
                    unew(ind_cell(i),2       )= 0.0_dp
                    
                    ! Compute Rosseland opacity
                    t2r = cal_Teg(unew(ind_cell(i),firstindex_er+igroup)*scale_E0,igroup)
                    divu(ind_cell(i))= rosseland_ana(dd*scale_d,t2,t2r,igroup)/scale_kappa
                    if(divu(ind_cell(i))*dx_loc .lt. min_optical_depth) divu(ind_cell(i))=min_optical_depth/dx_loc
                    
                 end if
              end do
!!            end if
              
        end do
        ! End loop over cells
           
     end do
     ! End loop over grids

  end do
  ! End loop over boundaries


111 format('   Entering make_boundary_diffusion for level ',I2)

end subroutine make_boundary_diffusion

!################################################################
!################################################################
!################################################################ 
!################################################################

subroutine make_boundary_diffusion_tot(ilevel)
  use amr_commons,only:boundary,son,ncoarse,nbor,xg
  use hydro_commons
  use cooling_module,ONLY:kB,mH,clight
  use radiation_parameters
  use const
  use units_commons
  implicit none
  ! -------------------------------------------------------------------
  ! This routine set up boundary conditions for fine levels.
  ! -------------------------------------------------------------------
  integer,intent(IN)::ilevel
  integer::ibound,boundary_dir,idim,inbor,igroup,ht
  integer::i,ncache,ivar,igrid,ngrid,ind
  integer::iskip,iskip_ref,gdim,nx_loc,ix,iy,iz,igrp,irad
  integer,dimension(1:8)::ind_ref
  integer,dimension(1:nvector),save::ind_grid,ind_grid_ref
  integer,dimension(1:nvector),save::ind_cell,ind_cell_ref

  real(dp)::dx,dx_loc,scale
  real(dp)::rosseland_ana,planck_ana
  real(dp),dimension(1:3)::skip_loc
  real(dp),dimension(1:twotondim,1:3)::xc
  real(dp),dimension(1:nvector,1:ndim),save::xx
  real(dp),dimension(1:nvector,1:nvar+3),save::uu
  real(dp),dimension(1:nvector)::cond,relax
  real(dp)::dd,t2,t2r,cal_Teg,usquare,emag,erad_loc,eps,ekin,Cv,rho
  
  real(dp):: sum_dust
#if NDUST>0
  integer :: idust
#endif 
  if(.not. simple_boundary)return

  ! Mesh size at level ilevel
  dx=half**ilevel

  ! Rescaling factors
  nx_loc=(icoarse_max-icoarse_min+1)
  skip_loc=(/zero,zero,zero/)
  if(ndim>0)skip_loc(1)=dble(icoarse_min)
  if(ndim>1)skip_loc(2)=dble(jcoarse_min)
  if(ndim>2)skip_loc(3)=dble(kcoarse_min)
  scale=boxlen/dble(nx_loc)
  dx_loc=dx*scale

  ! Set position of cell centers relative to grid center
  do ind=1,twotondim
     iz=(ind-1)/4
     iy=(ind-1-4*iz)/2
     ix=(ind-1-2*iy-4*iz)
     if(ndim>0)xc(ind,1)=(dble(ix)-half)*dx
     if(ndim>1)xc(ind,2)=(dble(iy)-half)*dx
     if(ndim>2)xc(ind,3)=(dble(iz)-half)*dx
  end do

  ! Loop over boundaries
  do ibound=1,nboundary
     ! Compute direction of reference neighbors
     boundary_dir=boundary_type(ibound)-10*(boundary_type(ibound)/10)
     if(boundary_dir==1)inbor=2

     if(boundary_dir==2)inbor=1
     if(boundary_dir==3)inbor=4
     if(boundary_dir==4)inbor=3
     if(boundary_dir==5)inbor=6
     if(boundary_dir==6)inbor=5

     ! Compute index of reference cells
     ! Zero flux
     if(boundary_type(ibound)== 1)ind_ref(1:8)=(/2,1,4,3,6,5,8,7/)
     if(boundary_type(ibound)== 2)ind_ref(1:8)=(/2,1,4,3,6,5,8,7/)
     if(boundary_type(ibound)== 3)ind_ref(1:8)=(/3,4,1,2,7,8,5,6/)
     if(boundary_type(ibound)== 4)ind_ref(1:8)=(/3,4,1,2,7,8,5,6/)
     if(boundary_type(ibound)== 5)ind_ref(1:8)=(/5,6,7,8,1,2,3,4/)
     if(boundary_type(ibound)== 6)ind_ref(1:8)=(/5,6,7,8,1,2,3,4/)
     ! Zero flux
     if(boundary_type(ibound)==11)ind_ref(1:8)=(/1,1,3,3,5,5,7,7/)
     if(boundary_type(ibound)==12)ind_ref(1:8)=(/2,2,4,4,6,6,8,8/)
     if(boundary_type(ibound)==13)ind_ref(1:8)=(/1,2,1,2,5,6,5,6/)
     if(boundary_type(ibound)==14)ind_ref(1:8)=(/3,4,3,4,7,8,7,8/)
     if(boundary_type(ibound)==15)ind_ref(1:8)=(/1,2,3,4,1,2,3,4/)
     if(boundary_type(ibound)==16)ind_ref(1:8)=(/5,6,7,8,5,6,7,8/)
     ! Imposed boundary
     if(boundary_type(ibound)==21)ind_ref(1:8)=(/1,1,3,3,5,5,7,7/)
     if(boundary_type(ibound)==22)ind_ref(1:8)=(/2,2,4,4,6,6,8,8/)
     if(boundary_type(ibound)==23)ind_ref(1:8)=(/1,2,1,2,5,6,5,6/)
     if(boundary_type(ibound)==24)ind_ref(1:8)=(/3,4,3,4,7,8,7,8/)
     if(boundary_type(ibound)==25)ind_ref(1:8)=(/1,2,3,4,1,2,3,4/)
     if(boundary_type(ibound)==26)ind_ref(1:8)=(/5,6,7,8,5,6,7,8/)

     ! Loop over grids by vector sweeps
     ncache=boundary(ibound,ilevel)%ngrid
     do igrid=1,ncache,nvector
        ngrid=MIN(nvector,ncache-igrid+1)
        do i=1,ngrid
           ind_grid(i)=boundary(ibound,ilevel)%igrid(igrid+i-1)
        end do

        ! Gather neighboring reference grid
        do i=1,ngrid
           ind_grid_ref(i)=son(nbor(ind_grid(i),inbor))
        end do

        ! Loop over cells
        do ind=1,twotondim
           iskip=ncoarse+(ind-1)*ngridmax
           do i=1,ngrid
              ind_cell(i)=iskip+ind_grid(i)
           end do

           ! Gather neighboring reference cell
           iskip_ref=ncoarse+(ind_ref(ind)-1)*ngridmax
           do i=1,ngrid
              ind_cell_ref(i)=iskip_ref+ind_grid_ref(i)
           end do

!!            ! Zero flux boundary conditions
!!            if((boundary_type(ibound)/10).ne.2)then
!! 
!!               ! Gather reference variables and  scatter to boundary region
!!               do i=1,ngrid
!!                  if(son(ind_cell(i)) == 0)then
!! #if USE_FLD==1
!!                     do igroup=1,ngrp
!!                        kappaR_bicg(ind_cell(i),igroup)       = kappaR_bicg(ind_cell_ref(i),igroup)
!!                     enddo
!! #endif
!!                     do irad=1,nvar_trad
!!                        unew    (ind_cell(i),ind_trad(irad)) = unew    (ind_cell_ref(i),ind_trad(irad))
!!                        uold    (ind_cell(i),ind_trad(irad)) = uold    (ind_cell_ref(i),ind_trad(irad))
!!                     enddo
!!                     do irad = 1,nvar_bicg
!!                        if(bicg_to_cg) var_bicg(ind_cell(i),irad, 2) = var_bicg(ind_cell_ref(i),irad, 2)
!!                        var_bicg(ind_cell(i),irad, 5) = var_bicg(ind_cell_ref(i),irad, 5)
!!                        if(.not.bicg_to_cg) var_bicg(ind_cell(i),irad, 6) = var_bicg(ind_cell_ref(i),irad, 6)
!!                     enddo
!! 
!!                  end if
!!               end do
!! 
!!               ! Imposed boundary conditions
!!            else

              ! Compute cell center in code units and rescale position from code units to user units
              do idim=1,ndim
                 do i=1,ngrid
                    if(son(ind_cell(i)) == 0)then
                       xx(i,idim)=(xg(ind_grid(i),idim)+xc(ind,idim)-skip_loc(idim))*scale
                    end if
                 end do
              end do

              call boundana(xx,uu,dx_loc,ibound,ngrid)

              ! Scatter variables
              do i=1,ngrid 
                 if(son(ind_cell(i)) == 0)then
                    dd=max(uu(i,1),smallr)

                    usquare=zero
                    do idim=1,ndim
                       usquare=usquare+(uu(i,idim+1)/uu(i,1))**2
                    end do
                    ! Compute total magnetic energy
                    emag = zero
                    do ivar=1,3
                       emag = emag + 0.125_dp*(uu(i,5+ivar) + uu(i,nvar+ivar))**2
                    end do
                    ! Compute total non-thermal+radiative energy
                    erad_loc=zero
                    do igrp=1,nener
                       erad_loc=erad_loc+uu(i,8+igrp)
                    enddo

                    rho   = uu(i,1)
                    ekin  = rho*usquare*half
                    eps   = (uu(i,5)-ekin-emag-erad_loc)
                    sum_dust =0.0_dp
#if NDUST>0
                    do idust = 1, ndust
                       sum_dust = sum_dust + uu(i,firstindex_ndust+idust)/rho
                    end do
#endif       
                    call temperature_eos(rho*(1.0_dp-sum_dust),eps,t2,ht)

#if NGRP>0
                    uu(i,ind_trad(1)) = t2
                    uu(i,ind_trad(1)) = Tr_floor ! comment this for radiative shock
#endif

#if USE_FLD==1
                    ! Compute Rosseland opacity
                    do igroup=1,ngrp
                       t2r = cal_Teg(uu(i,firstindex_er+igroup)*scale_d*scale_v**2,igroup)
                       kappaR_bicg(ind_cell(i),igroup)= rosseland_ana(dd*scale_d,uu(i,ind_trad(1)),t2r,igroup)/scale_kappa
                       if( kappaR_bicg(ind_cell(i),igroup)*dx_loc .lt. min_optical_depth)  kappaR_bicg(ind_cell(i),igroup)=min_optical_depth/dx_loc
                    enddo
#endif
                    do irad=1,nvar_trad
                       uold(ind_cell(i),ind_trad(irad)) = uu(i,ind_trad(irad)) / norm_trad(irad)
                       unew(ind_cell(i),ind_trad(irad)) = uold(ind_cell(i),ind_trad(irad))
                    enddo

                   do irad = 1,nvar_bicg
                      if(bicg_to_cg) var_bicg(ind_cell(i),irad, 2) = zero
                      var_bicg(ind_cell(i),irad, 5) = zero
                      if(.not.bicg_to_cg) var_bicg(ind_cell(i),irad, 6) = zero
                   enddo

                 end if
              end do

!!            end if

        end do
        ! End loop over cells

     end do
     ! End loop over grids

  end do
  ! End loop over boundaries


111 format('   Entering make_boundary_diffusion for level ',I2)

end subroutine make_boundary_diffusion_tot
../patch/collapse/radiation_parameters.f90
module radiation_parameters
  use amr_parameters
  use hydro_parameters,only:ngrp,nvar_bicg,nvar_trad

  ! DT adaptatif
  real(dp),allocatable,dimension(:,:)::rad_flux ! Flux entrant dans une cellule
  real(dp),allocatable,dimension(:,:)::urad     ! Old values of Erg in NR iterations
  real(dp),allocatable,dimension(:,:)::frad     ! Radiative force  
  real(dp)::Tr_floor=10.0 ! Background radiation field temperature - WARNING: it affects the pressure_fix in set_uold.
  integer::ntp,nfr

  real(dp):: alpha_imp = 1.0d0	!0.0:explicite 0.5:CN 1.0:implicite
  real(dp):: robin = 1.0d0	!0.0:Von Neumann 1.0:Dirichlet

  ! Multigroup
  integer,parameter::Nomega=100     ! Number of points in the omega data to compute Q moment term

  real(dp),parameter:: aR=7.56591469318689378e-015_dp
  real(dp),parameter::Tray_min=0.5d0 ! Minimum temperature in the radiative energy
  real(dp),parameter:: eray_min=(aR)*Tray_min**4 ! minimum rad energy inside frequency group
  real(dp),parameter:: deray_min=(4.0d0*aR)*Tray_min**3 ! minimum rad energy derivative inside frequency group
  real(dp):: small_er=1.0d-30       ! minimum rad energy inside frequency group in code units
  
  real(dp) :: numin=1.0d5,numax=1.0d19 ! Overall frequency boudaries
  real(dp) :: frequency_upperlimit=1.0d35 ! High end frequency if 'extra_end_group = .true.

  integer::Ninv_art4=1000                               ! Number of points in tabulated arT4 function
  real(dp),dimension(:    ),allocatable::dEr_inv_art4   ! Radiative energy increment
  real(dp),dimension(:,:  ),allocatable::inverse_art4_T ! array for tabulated arT4 function dT regular
  real(dp),dimension(:,:,:),allocatable::inverse_art4_E ! array for tabulated arT4 function dE regular
  
  real(dp), dimension(:), allocatable :: nu_min_hz ! minimum freq of given group in Hz
  real(dp), dimension(:), allocatable :: nu_max_hz ! maximum freq of given group in Hz
  real(dp), dimension(:), allocatable :: nu_min_ev ! minimum freq of given group in eV
  real(dp), dimension(:), allocatable :: nu_max_ev ! maximum freq of given group in eV
  
  real(dp),dimension(0:Nomega):: f_array,w1_array,dw1_array,w2_array,dw2_array ! Arrays of omega terms for Q computation

  logical :: freqs_in_Hz=.true.      ! Frequency units in Hz if true; if not eV
  logical :: read_groups=.false.     ! Read group boundaries from file if true
  logical :: split_groups_log=.true. ! Automatic splitting of group in log if true; if not use regular splitting
  logical :: extra_end_group=.false. ! The last group holds frequencies numax -> frequency_upperlimit if true
  logical :: grey_rad_transfer=.true.! Default: grey radiation transfer
  logical :: external_radiation_field=.false. ! Default: No external radiation background (@ Tr_floor)
  logical :: stellar_photon=.false.  ! Stellar photons are treated as a separate group (igrp=1). No emission for this group (radiation_source=0)
  logical :: sinks_opt_thin=.false.  ! Optically-thin (min_optical_depth) sink volumes, relevant for hybrid RT

  ! Opacities
  character(len=12) :: opacity_type = 'grey'  ! 'grey' or 'multigroup'
  logical :: sublimation_kuiper=.false. ! Mimicks dust sublimation with decreasing d/g ratio, see Kuiper+10 ApJ

  ! Radiation solver parameters
  real(dp)::epsilon_diff=1d-6                        ! CG iteration break criteria
  character(LEN=10)::fld_limiter='nolim'             ! Flux limiter (nolim, levermore or minerbo)
  integer::i_fld_limiter
  integer,parameter::i_fld_limiter_nolim=0
  integer,parameter::i_fld_limiter_minerbo=1
  integer,parameter::i_fld_limiter_levermore=2
  integer :: niter=0                                 ! Total number of iteration
  real(dp),dimension(1:10)::dtdiff_params=1d10       ! Conduction time step behaviour
  real(dp),dimension(1:10)::rosseland_params=1.0     ! Rosseland opacity coefficient's parameters
  real(dp),dimension(1:10)::planck_params=1.0        ! Planck opacity coefficient's parameters
  real(dp)::mu_gas=2.31d0                            ! For Saumon Chabrier EOS
  real(dp)::min_optical_depth=1.d-6        ! set the minimum optical depth in the cell (it may accelerate convergence in optically thin regions)

  ! Variables needed for BICG scheme
  real(dp),dimension(:,:,:,:),allocatable :: coeff_glob_left,coeff_glob_right
  real(dp),dimension(:,:,:  ),allocatable :: var_bicg,precond_bicg
  real(dp),dimension(:,:,:  ),allocatable :: mat_residual_glob
  real(dp),dimension(:,:    ),allocatable :: residual_glob
  real(dp),dimension(:,:    ),allocatable :: kappaR_bicg
  logical::block_diagonal_precond_bicg ! if .false. only diagonal, if .true. block diagonal
  integer :: i_rho,i_beta,i_y,i_pAp,i_s
  integer , dimension(1:nvar_bicg) :: ind_bicg
  real(dp), dimension(1:nvar_bicg) :: norm_bicg
  integer , dimension(1:nvar_trad) :: ind_trad
  real(dp), dimension(1:nvar_trad) :: norm_trad
  logical , dimension(1:nvar_trad) :: is_radiative_energy

  integer                                   :: irad_trans_model        !< Integer designating radiative transfer model: 0 = P1, 1 = M1
  integer, parameter                        :: irad_trans_model_p1 = 0 !< P1 radiative transfer model identifier
  integer, parameter                        :: irad_trans_model_m1 = 1 !< M1 radiative transfer model identifier
  integer                                   :: n_points                !< Number of points in the tabulated eigenvalues curve
  real(dp), dimension(:,:,:,:), allocatable :: valp                    !< Array to hold the tabulated eigenvalues as a function of \f \theta\f  and \f \epsilon\f 
  real(dp)                                  :: valp_min=0.0_dp

  logical::store_matrix=.true.

#if USE_FLD==1 && NGRP == 1
  logical, parameter :: bicg_to_cg = .true.
#else
  logical, parameter :: bicg_to_cg = .false.
#endif

end module radiation_parameters

!##################################################################################################
!##################################################################################################
!##################################################################################################
!##################################################################################################

!  Module MOD_OPACITIES:
!
!>  Module for opacities
!<
module mod_opacities
  use amr_parameters, only : dp
  implicit none
  real(dp), dimension(:,:,:,:), allocatable :: kappa_opmesh_p      !< Regular mesh of Planck opacities
  real(dp), dimension(:,:,:,:), allocatable :: kappa_opmesh_r      !< Regular mesh of Rosseland opacities
  real(dp), dimension(:,:,:  ), allocatable :: kappa_dustgas_p     !< Rosseland opacities from Dust + Gas
  real(dp), dimension(:,:,:  ), allocatable :: kappa_dustgas_r     !< Rosseland opacities from Dust + Gas
  real(dp), dimension(:      ), allocatable :: logt_dustgas        !< Temperature of points for Dust+Gas data
  real(dp), dimension(:      ), allocatable :: logd_dustgas        !< Density of points for Dust+Gas data
  real(dp), dimension(:      ), allocatable :: x_opmesh            !< X (density) coordinates of mesh points
  real(dp), dimension(:      ), allocatable :: y_opmesh            !< Y (temperature) coordinates of mesh points
  real(dp), dimension(:      ), allocatable :: z_opmesh            !< Z (rad temperature) coordinates of mesh points
  real(dp), dimension(:      ), allocatable :: numin_dustgas       !< Minimum freq. in Dust+Gas opacities
  real(dp), dimension(:      ), allocatable :: numax_dustgas       !< Maximum freq. in Dust+Gas opacities
  real(dp), dimension(:      ), allocatable :: extrapol_min        !< Extrapolation power for low frequencies
  real(dp), dimension(:      ), allocatable :: extrapol_max        !< Extrapolation power for high frequencies
  integer , dimension(:      ), allocatable :: nfreq_dustgas       !< Number of freq. in Dust+Gas opacities
  integer                                   :: nx_opmesh           !< Number of X points in opacity mesh
  integer                                   :: ny_opmesh           !< Number of Y points in opacity mesh
  integer                                   :: nz_opmesh           !< Number of Z points in opacity mesh
  integer                                   :: npoints             !< Number of points in freq. for Dust+Gas opacities
  real(dp)                                  :: tmin_op             !< 
  real(dp)                                  :: dx_opmesh           !< dx in opacity mesh
  real(dp)                                  :: dy_opmesh           !< dy in opacity mesh
  real(dp)                                  :: dz_opmesh           !< dy in opacity mesh
  real(dp)                                  :: opacity_dtemp
  real(dp), parameter                       :: t_grain_sublim = 1.5e+03_dp !< Grain sublimation temperature
end module mod_opacities

!##################################################################################################
!##################################################################################################
!##################################################################################################
!##################################################################################################

!  Subroutine INIT_OPACITIES_DUST_AND_GAS:
!
!> Read opacities for dust from Semenov+Draine and gas from Franck.
!!    - The arbitrary points in Rho and T are read.
!!    - The Planck and Rosseland means are computed for each point for each group.
!!    - A Delaunay triangulation is computed from the points.
!!    - Each triangle defines a plane in 3D.
!!    - Then a finer but regular mesh in (Rho,T) is overlayed onto the triangulation.
!!    - This gives a regular mesh of Planck and Rosseland means to perform bicubic interpolations.
!<
subroutine init_opacities

  use radiation_parameters
  use mod_opacities
  use amr_commons, only : myid,nrestart

  implicit none

  integer                                 :: i,igroup,ipoint,j,it,nnumax,k,l,kw,kernel_size,istep
  integer                                 :: inu_min1,inu_max1,inu_min2,inu_max2,nparts,iprog,itrad
  integer                                 :: datasize,dataread,percentage,nneighbours,in,ii,jj,kk,np
  integer                                 :: iter,itermax,ntot,nmin,maxneighbours,nn,n,npasses,ntrad
  logical                                 :: enough_points_found,hole_filled
  real(dp), dimension(:    ), allocatable :: opnu,opknu
  real(dp), dimension(:,:,:), allocatable :: bin_count
  real(dp)                                :: integral1,integral2,integral3,integral4,integral5,integral6
  real(dp)                                :: dist,distmin,temp,x,y,xa,ya,xx,yy,dtrad
  real(dp)                                :: dmax_opmesh,dmin_opmesh,tmax_opmesh,tmin_opmesh,trmax_opmesh,trmin_opmesh
  real(dp)                                :: nu1,nu2,op1,op2,m,slope,dnu,kappa_min,grad1,grad2,minmod
  character (len=200)                     :: opfilename,fname
  logical , dimension(:,:,:), allocatable :: i_am_a_hole

  if(opacity_type == 'multigroup')then

     if(nrestart .eq. 0)then
        opfilename = 'VaytetEtAl2013AandA557A90_opacities.bin'

        if(myid==1)then
           write(*,*)
           write(*,*) '############# MULTIGROUP DUST AND GAS OPACITIES ##############'
           write(*,*) 'Reading opacity table: '//trim(opfilename)
           write(*,*) '=============================================================='
           write(*,*) 'Opacities: Vaytet et al. 2013, A&A, 557, A90'
           write(*,*) 'COMPUTING Planck and Rosseland mean opacities for:'
           write(*,*) ' - DUST (Semenov et al. 2003, Draine 2003) : 5K < T < 1500K'
           write(*,*) ' - MOLECULAR GAS (Ferguson et al. 2005): 1500K < T < 3200K'
           write(*,*) ' - ATOMIC GAS (Badnell et al. 2005): 3200K < T < 1.0e8K'
           write(*,*) '=============================================================='
        endif

        !####### Set variables #######
        nx_opmesh      = 100
        ny_opmesh      = 100
        nz_opmesh      = 100
        dmin_opmesh    = -24.00_dp
        dmax_opmesh    =   6.00_dp
        tmin_opmesh    =   0.00_dp
        tmax_opmesh    =   8.00_dp
        trmin_opmesh   =   0.00_dp
        trmax_opmesh   =   8.00_dp
        nparts         = 10
        ntrad          = 150
        kappa_min      = 1.0e-50_dp
        datasize       = 31637055
        !#############################

        dtrad = (trmax_opmesh-trmin_opmesh)/real(ntrad-1,dp)

        open(78,file=opfilename,form='unformatted')
        read(78) npoints,nnumax

        allocate(opnu(nnumax),opknu(nnumax))
        allocate(logt_dustgas(npoints),logd_dustgas(npoints))
        allocate(numin_dustgas(npoints),numax_dustgas(npoints),nfreq_dustgas(npoints))
        allocate(extrapol_min(npoints),extrapol_max(npoints))
        allocate(kappa_dustgas_p(ngrp,npoints,ntrad),kappa_dustgas_r(ngrp,npoints,ntrad))

        istep = 1
        iprog = 0
        dataread = 0

        do ipoint = 1,npoints

           percentage = nint(real(dataread)*100.0/real(datasize))

           if((myid==1) .and. (percentage .ge. iprog*istep))then
              write(*,'(i3,a)') percentage,'% complete'
              iprog = iprog + 1
           endif

           read(78) logd_dustgas(ipoint),logt_dustgas(ipoint)
           read(78) nfreq_dustgas(ipoint),numin_dustgas(ipoint),numax_dustgas(ipoint)
           read(78) extrapol_min(ipoint),extrapol_max(ipoint)
           read(78) opnu (1:nfreq_dustgas(ipoint))
           read(78) opknu(1:nfreq_dustgas(ipoint))

           dataread = dataread + nfreq_dustgas(ipoint)

           ! Begin loop over Trad
           do itrad = 1,ntrad

              temp = 10.0_dp**(real(itrad-1,dp)*dtrad + trmin_opmesh)

              ! find group boundaries
              inu_min1 = 0 ; inu_max1 = 0
              inu_min2 = 0 ; inu_max2 = 0

              do igroup = 1,ngrp

                 if(nu_min_hz(igroup) .lt. opnu(1))then
                    inu_min1 = 1 ; inu_min2 = 1
                 elseif(nu_min_hz(igroup) .ge. opnu(nfreq_dustgas(ipoint)))then
                    inu_min1 = nfreq_dustgas(ipoint) ; inu_min2 = nfreq_dustgas(ipoint)
                 else
                    do i = 1,nfreq_dustgas(ipoint)-1
                       if((nu_min_hz(igroup) .ge. opnu(i)).and.(nu_min_hz(igroup) .lt. opnu(i+1)))then
                          inu_min1 = i ; inu_min2 = i+1
                          exit
                       endif
                    enddo
                 endif

                 if(nu_max_hz(igroup) .lt. opnu(1))then
                    inu_max1 = 1 ; inu_max2 = 1
                 elseif(nu_max_hz(igroup) .ge. opnu(nfreq_dustgas(ipoint)))then
                    inu_max1 = nfreq_dustgas(ipoint) ; inu_max2 = nfreq_dustgas(ipoint)
                 else
                    do i = 1,nfreq_dustgas(ipoint)-1
                       if((nu_max_hz(igroup) .ge. opnu(i)).and.(nu_max_hz(igroup) .lt. opnu(i+1)))then
                          inu_max1 = i ; inu_max2 = i+1
                          exit
                       endif
                    enddo
                 endif

                 ! compute Planck and Rosseland mean opacities

                 integral1 = 0.0_dp
                 integral2 = 0.0_dp
                 integral3 = 0.0_dp
                 integral4 = 0.0_dp
                 integral5 = 0.0_dp
                 integral6 = 0.0_dp

                 ! If first frequency is outside opacity frequency range
                 if(inu_min1 .eq. inu_min2)then
                    ! Case where both frequencies are outside table on the same side
                    if(inu_min1 .eq. inu_max1)then
                       ! Select which slope to use
                       if(inu_min1 .eq. 1)then
                          slope = extrapol_min(ipoint)
                       else
                          slope = extrapol_max(ipoint)
                       endif
                       ! Split interval into 10 parts
                       dnu = (log10(nu_max_hz(igroup)) - log10(nu_min_hz(igroup)))/real(nparts,dp)
                       do i = 1,nparts
                          nu1 = 10.0_dp**(real(i-1,dp)*dnu + log10(nu_min_hz(igroup)))
                          nu2 = 10.0_dp**(real(i  ,dp)*dnu + log10(nu_min_hz(igroup)))
                          op1 = 10.0_dp**(slope * (log10(nu1)-log10(opnu(inu_min1))) + log10(opknu(inu_min1)))
                          op2 = 10.0_dp**(slope * (log10(nu2)-log10(opnu(inu_min1))) + log10(opknu(inu_min1)))
                          op1 = max(op1,kappa_min)
                          op2 = max(op2,kappa_min)
                          call compute_integral(integral1,integral2,integral3,integral4, &
                               integral5,integral6,nu1,nu2,op1,op2,temp)
                       enddo
                    else
                       !Case where only numin is outside of range
                       ! Select which slope to use
                       if(inu_min1 .eq. 1)then
                          slope = extrapol_min(ipoint)
                       else
                          slope = extrapol_max(ipoint)
                       endif
                       ! Split interval into 10 parts
                       dnu = (log10(opnu(inu_min1))-log10(nu_min_hz(igroup)))/real(nparts,dp)
                       do i = 1,nparts
                          nu1 = 10.0_dp**(real(i-1,dp)*dnu + log10(nu_min_hz(igroup)))
                          nu2 = 10.0_dp**(real(i  ,dp)*dnu + log10(nu_min_hz(igroup)))
                          op1 = 10.0_dp**(slope * (log10(nu1)-log10(opnu(inu_min1))) + log10(opknu(inu_min1)))
                          op2 = 10.0_dp**(slope * (log10(nu2)-log10(opnu(inu_min1))) + log10(opknu(inu_min1)))
                          op1 = max(op1,kappa_min)
                          op2 = max(op2,kappa_min)
                          call compute_integral(integral1,integral2,integral3,integral4, &
                               integral5,integral6,nu1,nu2,op1,op2,temp)
                       enddo
                    endif
                 endif

                 ! If last frequency is outside opacity frequency range
                 if((inu_max1 .eq. nfreq_dustgas(ipoint)) .and. (inu_max1 .eq. inu_max1))then
                    !Case where numax is outside of range
                    slope = extrapol_max(ipoint)
                    ! Split interval into 10 parts
                    dnu = (log10(nu_max_hz(igroup))-log10(opnu(inu_max1)))/real(nparts,dp)
                    do i = 1,nparts
                       nu1 = 10.0_dp**(real(i-1,dp)*dnu + log10(opnu(inu_max1)))
                       nu2 = 10.0_dp**(real(i  ,dp)*dnu + log10(opnu(inu_max1)))
                       op1 = 10.0_dp**(slope * (log10(nu1)-log10(opnu(inu_max1))) + log10(opknu(inu_max1)))
                       op2 = 10.0_dp**(slope * (log10(nu2)-log10(opnu(inu_max1))) + log10(opknu(inu_max1)))
                       op1 = max(op1,kappa_min)
                       op2 = max(op2,kappa_min)
                       call compute_integral(integral1,integral2,integral3,integral4, &
                            integral5,integral6,nu1,nu2,op1,op2,temp)
                    enddo
                 endif

                 ! First part of the curve between numin and inumin
                 if(inu_min1 .ne. inu_min2)then
                    nu1 = opnu (inu_min1)
                    nu2 = opnu (inu_min2)
                    m = ( opknu(inu_min2) - opknu(inu_min1) ) / (nu2 - nu1)
                    op1 = m * (nu_min_hz(igroup)-nu1) + opknu(inu_min1)
                    op2 = opknu(inu_min2)
                    nu1 = nu_min_hz(igroup)
                    call compute_integral(integral1,integral2,integral3,integral4, &
                         integral5,integral6,nu1,nu2,op1,op2,temp)
                 endif

                 ! Last part of the curve between inumax and numax
                 if(inu_max1 .ne. inu_max2)then
                    nu1 = opnu (inu_max1)
                    nu2 = opnu (inu_max2)
                    m = ( opknu(inu_max2) - opknu(inu_max1) ) / (nu2 - nu1)
                    op1 = opknu(inu_max1)
                    op2 = m * (nu_max_hz(igroup)-nu1) + opknu(inu_max1)
                    nu2 = nu_max_hz(igroup)
                    call compute_integral(integral1,integral2,integral3,integral4, &
                         integral5,integral6,nu1,nu2,op1,op2,temp)
                 endif

                 ! Middle part between inumin and inumax
                 do i = inu_min2,inu_max1-1
                    nu1 = opnu (i  )
                    nu2 = opnu (i+1)
                    op1 = opknu(i  )
                    op2 = opknu(i+1)
                    call compute_integral(integral1,integral2,integral3,integral4, &
                         integral5,integral6,nu1,nu2,op1,op2,temp)
                 enddo

                 if(abs(integral1) < 1.0e-50_dp)then
                    kappa_dustgas_p(igroup,ipoint,itrad) = integral5 / integral6
                 else
                    kappa_dustgas_p(igroup,ipoint,itrad) = integral1 / integral2
                 endif
                 if(abs(integral3) < 1.0e-50_dp)then
                    kappa_dustgas_r(igroup,ipoint,itrad) = integral5 / integral6
                 else
                    kappa_dustgas_r(igroup,ipoint,itrad) = integral3 / integral4
                 endif

                 !         if(logt_dustgas(ipoint) > 5.0)then
                 !            write(*,*) ipoint,igroup,integral1,integral2,integral3,integral4,&
                 !                       kappa_dustgas_p(igroup,ipoint),kappa_dustgas_r(igroup,ipoint)
                 !         endif

              enddo ! end do igroup = 1,ngrp

           enddo ! end do itrad = 1,ntrad

        enddo ! end do ipoint = 1,npoints

        close(78)

        if(myid==1)then
           write(*,*) 'Number of points:',npoints
           write(*,*) 'Rhomin,Rhomax:',minval(logd_dustgas),maxval(logd_dustgas)
           write(*,*) 'Tmin,Tmax:',minval(logt_dustgas),maxval(logt_dustgas)
        endif

        ! Create a mesh of (rho,T) points:
        if(myid==1) write(*,*) 'Computing regular mesh of opacities'

        allocate(bin_count(nx_opmesh,ny_opmesh,nz_opmesh),i_am_a_hole(nx_opmesh,ny_opmesh,nz_opmesh))
        allocate(kappa_opmesh_p(ngrp,nx_opmesh,ny_opmesh,nz_opmesh),kappa_opmesh_r(ngrp,nx_opmesh,ny_opmesh,nz_opmesh))
        allocate(x_opmesh(nx_opmesh),y_opmesh(ny_opmesh),z_opmesh(nz_opmesh))

        dx_opmesh = (dmax_opmesh-dmin_opmesh)/real(nx_opmesh-1,dp)
        dy_opmesh = (tmax_opmesh-tmin_opmesh)/real(ny_opmesh-1,dp)
        dz_opmesh = (trmax_opmesh-trmin_opmesh)/real(nz_opmesh-1,dp)     

        x_opmesh(1) = dmin_opmesh
        y_opmesh(1) = tmin_opmesh
        z_opmesh(1) = trmin_opmesh

        do i = 2,nx_opmesh
           x_opmesh(i) = x_opmesh(i-1) + dx_opmesh
        enddo
        do j = 2,ny_opmesh
           y_opmesh(j) = y_opmesh(j-1) + dy_opmesh
        enddo
        do k = 2,nz_opmesh
           z_opmesh(k) = z_opmesh(k-1) + dz_opmesh
        enddo

        bin_count = 0.0_dp
        kappa_opmesh_p = 0.0_dp
        kappa_opmesh_r = 0.0_dp
        i_am_a_hole = .true.

        do ipoint = 1,npoints

           i = floor((logd_dustgas(ipoint)-dmin_opmesh)/dx_opmesh - 0.5_dp) + 2
           j = floor((logt_dustgas(ipoint)-tmin_opmesh)/dy_opmesh - 0.5_dp) + 2

           ! now search along Trad direction
           do itrad = 1,ntrad
              temp = real(itrad-1,dp)*dtrad + trmin_opmesh

              k = floor((temp-tmin_opmesh)/dz_opmesh - 0.5_dp) + 2

              do igroup = 1,ngrp
                 kappa_opmesh_p(igroup,i,j,k) = kappa_opmesh_p(igroup,i,j,k) + kappa_dustgas_p(igroup,ipoint,itrad)
                 kappa_opmesh_r(igroup,i,j,k) = kappa_opmesh_r(igroup,i,j,k) + kappa_dustgas_r(igroup,ipoint,itrad)
              enddo

              bin_count(i,j,k) = bin_count(i,j,k) + 1.0_dp
              i_am_a_hole(i,j,k) = .false.

           enddo

        enddo

        do k = 1,nz_opmesh
           do j = 1,ny_opmesh
              do i = 1,nx_opmesh
                 if(i_am_a_hole(i,j,k))then
                    do igroup = 1,ngrp
                       kappa_opmesh_p(igroup,i,j,k) = 1.0e-30_dp
                       kappa_opmesh_r(igroup,i,j,k) = 1.0e-30_dp
                    enddo
                 else
                    do igroup = 1,ngrp
                       kappa_opmesh_p(igroup,i,j,k) = kappa_opmesh_p(igroup,i,j,k) / bin_count(i,j,k)
                       kappa_opmesh_r(igroup,i,j,k) = kappa_opmesh_r(igroup,i,j,k) / bin_count(i,j,k)
                    enddo
                 endif
              enddo
           enddo
        enddo

        ! Convert to log
        kappa_opmesh_p = log10(kappa_opmesh_p)
        kappa_opmesh_r = log10(kappa_opmesh_r)

        ! Now fill holes in table
        if(myid==1)write(*,*) 'Filling holes in table...'

        ! First find holes which are surrounded by many points, and then go to bigger ang bigger holes

        npasses = 10 ! number of times to perform filling process

        do n = 1,npasses

           nneighbours = 26
           maxneighbours = 0
           itermax = 8
           do in = nneighbours,0,-1

              do k = 1,nz_opmesh
                 do j = 1,ny_opmesh
                    do i = 1,nx_opmesh
                       if(i_am_a_hole(i,j,k))then

                          ! Find number of neighbours
                          nn = 0
                          do ii = max(i-1,1),min(i+1,nx_opmesh)
                             do jj = max(j-1,1),min(j+1,ny_opmesh)
                                do kk = max(k-1,1),min(k+1,nz_opmesh)
                                   if(.not.i_am_a_hole(ii,jj,kk))then
                                      nn = nn + 1
                                   endif
                                enddo
                             enddo
                          enddo

                          if(nn == in)then

                             hole_filled = .false.

                             do igroup = 1,ngrp

                                do iter = 1,itermax

                                   np = 0
                                   xx = 0.0_dp
                                   yy = 0.0_dp
                                   ntot = (1 + 2*iter)**3 - 1
                                   nmin = int(2.0_dp*sqrt(real(ntot,dp)))   ! ntot / 2 + 1
                                   enough_points_found = .false.

                                   do ii = max(i-iter,1),min(i+iter,nx_opmesh)
                                      do jj = max(j-iter,1),min(j+iter,ny_opmesh)
                                         do kk = max(k-iter,1),min(k+iter,nz_opmesh)

                                            if(.not.i_am_a_hole(ii,jj,kk))then
                                               xx = xx + kappa_opmesh_p(igroup,ii,jj,kk)
                                               yy = yy + kappa_opmesh_r(igroup,ii,jj,kk)
                                               np = np + 1
                                            endif

                                         enddo
                                      enddo
                                   enddo

                                   if(np .ge. nmin)then
                                      enough_points_found = .true.
                                      exit
                                   endif

                                enddo

                                if(enough_points_found)then
                                   kappa_opmesh_p(igroup,i,j,k) = xx / real(np,dp)
                                   kappa_opmesh_r(igroup,i,j,k) = yy / real(np,dp)
                                   hole_filled = .true.
                                endif

                             enddo

                             if(hole_filled) i_am_a_hole(i,j,k) = .false.

                          endif

                       endif

                    enddo ! end do i = 1,nx_opmesh
                 enddo ! end do j = 1,ny_opmesh
              enddo ! end do k = 1,nz_opmesh

           enddo ! end do in = nneighbours,0,-1

        enddo ! end do n = 1,npasses

        if(myid==1)write(*,*) 'Done'

        ! Free memory
        deallocate(opnu,opknu)
        deallocate(logt_dustgas,logd_dustgas)
        deallocate(numin_dustgas,numax_dustgas,nfreq_dustgas)
        deallocate(extrapol_min,extrapol_max)
        deallocate(kappa_dustgas_p,kappa_dustgas_r)
        deallocate(bin_count,i_am_a_hole)

        if(myid==1)then
           open (79,file='multigroup_opacity.bin',form='unformatted')
           write (79) nx_opmesh,ny_opmesh,nz_opmesh,dx_opmesh,dy_opmesh,dz_opmesh,dmin_opmesh,dmax_opmesh,tmin_opmesh,tmax_opmesh,trmin_opmesh,trmax_opmesh

           write (79) x_opmesh
           write (79) y_opmesh
           write (79) z_opmesh
           write (79) kappa_opmesh_p(1:ngrp,1:nx_opmesh,1:ny_opmesh,1:nz_opmesh)
           write (79) kappa_opmesh_r(1:ngrp,1:nx_opmesh,1:ny_opmesh,1:nz_opmesh)
           close(79)
        end if
     else
        if(myid==1)write(*,*) 'Reading opacity table from previous run'

        open (80,file='multigroup_opacity.bin',form='unformatted')
        read (80) nx_opmesh,ny_opmesh,nz_opmesh,dx_opmesh,dy_opmesh,dz_opmesh,dmin_opmesh,dmax_opmesh,tmin_opmesh,tmax_opmesh,trmin_opmesh,trmax_opmesh

        allocate(x_opmesh(nx_opmesh),y_opmesh(ny_opmesh),z_opmesh(nz_opmesh))
        allocate(kappa_opmesh_p(ngrp,nx_opmesh,ny_opmesh,nz_opmesh),kappa_opmesh_r(ngrp,nx_opmesh,ny_opmesh,nz_opmesh))

        read (80) x_opmesh
        read (80) y_opmesh
        read (80) z_opmesh
        read (80) kappa_opmesh_p(1:ngrp,1:nx_opmesh,1:ny_opmesh,1:nz_opmesh)
        read (80) kappa_opmesh_r(1:ngrp,1:nx_opmesh,1:ny_opmesh,1:nz_opmesh)
        close(80)

     end if

  else

     if(ngrp .gt. 1 .and. myid==1)then
        write(*,*) 
        write(*,*) '=============================================================='
        write(*,*) 'WARNING: using grey opacities with NGROUP>1!'
        write(*,*) '=============================================================='
     end if

     opfilename = 'vaytet_grey_opacities3D.bin'

     if(myid==1)then
        write(*,*)
        write(*,*) '################ GREY DUST AND GAS OPACITIES #################'
        write(*,*) 'Reading opacity table: '//trim(opfilename)
        write(*,*) '=============================================================='
        write(*,*) 'Opacities: Vaytet et al. 2013, A&A, 557, A90'
        write(*,*) 'READING Planck and Rosseland mean opacities for:'
        write(*,*) ' - DUST (Semenov et al. 2003, Draine 2003) : 5K < T < 1500K'
        write(*,*) ' - MOLECULAR GAS (Ferguson et al. 2005): 1500K < T < 3200K'
        write(*,*) ' - ATOMIC GAS (Badnell et al. 2005): 3200K < T < 1.0e8K'
        write(*,*) '=============================================================='
     endif

     open (78,file=trim(opfilename),form='unformatted')
     read (78) nx_opmesh,ny_opmesh,nz_opmesh,dx_opmesh,dy_opmesh,dz_opmesh,dmin_opmesh,dmax_opmesh,tmin_opmesh,tmax_opmesh,trmin_opmesh,trmax_opmesh

     allocate(x_opmesh(nx_opmesh),y_opmesh(ny_opmesh),z_opmesh(nz_opmesh))
     allocate(kappa_opmesh_p(ngrp,nx_opmesh,ny_opmesh,nz_opmesh),kappa_opmesh_r(ngrp,nx_opmesh,ny_opmesh,nz_opmesh))

     read (78) x_opmesh
     read (78) y_opmesh
     read (78) z_opmesh
     read (78) kappa_opmesh_p(1,1:nx_opmesh,1:ny_opmesh,1:nz_opmesh)
     read (78) kappa_opmesh_r(1,1:nx_opmesh,1:ny_opmesh,1:nz_opmesh)
     close(78)

     if(ngrp .gt. 1)then
        do k = 1,nz_opmesh
           do j = 1,ny_opmesh
              do i = 1,nx_opmesh
                 do igroup=2,ngrp
                    kappa_opmesh_p(igroup,i,j,k) = kappa_opmesh_p(1,i,j,k)
                    kappa_opmesh_r(igroup,i,j,k) = kappa_opmesh_r(1,i,j,k)
                 end do
              end do
           end do
        end do
     end if
  endif

  if(myid==1)then
     write(*,*) 'INIT_OPACITIES complete'
     write(*,*) '##############################################################'
  endif

  return

end subroutine init_opacities

!##################################################################################################
!##################################################################################################
!##################################################################################################
!##################################################################################################

!  Function PLANCK_ANA:
!
!> Compute Planck average opacity.
!<
function planck_ana(dens,Tp,Tr,igroup,insink)

  use amr_commons
  use radiation_parameters
  use mod_opacities
  use pm_commons,only:Teff_sink

  implicit none

  integer, intent(in) :: igroup
  real(dp),intent(in) :: dens,Tp,Tr
  logical,intent(in)  :: insink

  integer             :: ival,jval,kval
  real(dp)            :: x,y,z,dx,dy,dz
  real(dp)            :: x0,x1,y0,y1,z0,z1
  real(dp)            :: c00,c01,c10,c11,c0,c1
  real(dp)            :: planck_ana,pi,Tgd
  real(dp)            :: Tevap ! if sublimation_kuiper
  real(dp)::scale_nH,scale_T2,scale_l,scale_d,scale_t,scale_v
  ! Conversion factor from user units to cgs units
  call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)

  if(sublimation_kuiper) then
     !# RMR #### Sublimation of dust grains as in kuiper+10 ApJ ####
     !### The highest dust temperature is the evaporation temperature
     !### Opacities are taken at this temperature
     !### The input temperature is kept to compute the d/g ratio
     Tgd = Tp
     Tevap = 2000.0d0*dens**0.0195  !! Evaporation temperature                                          
     if(Tp .gt. Tevap) Tgd = Tevap
  endif
  
  ! compute dust and gas opacities
  x = log10(dens)
  if(sublimation_kuiper) then
     y = log10(Tgd)  !! No dust grains above Tevap
  else
     y = log10(Tp)
  endif
  z = log10(Tr)
  if(stellar_photon)then
     if(igroup==1 .and. maxval(Teff_sink).gt.0)z = log10(maxval(Teff_sink)) 
  end if
    
  ival = floor((x - x_opmesh(1)) / dx_opmesh) + 1
  jval = floor((y - y_opmesh(1)) / dy_opmesh) + 1
  kval = floor((z - z_opmesh(1)) / dz_opmesh) + 1
  
  ! enforce to be in the table
  ival = min(max(ival,1),nx_opmesh)
  jval = min(max(jval,1),ny_opmesh)
  kval = min(max(kval,1),nz_opmesh)

  ! Perform tri-linear interpolation
  
  ! Compute coordinate deltas
  x0 = x_opmesh(ival  )
  x1 = x_opmesh(ival+1)
  y0 = y_opmesh(jval  )
  y1 = y_opmesh(jval+1)
  z0 = z_opmesh(kval  )
  z1 = z_opmesh(kval+1)
  
  dx = (x-x0)/(x1-x0)
  dy = (y-y0)/(y1-y0)
  dz = (z-z0)/(z1-z0)
  
  ! First linear interpolation along x
  c00 = kappa_opmesh_p(igroup,ival  ,jval  ,kval  )*(1.0_dp-dx) + kappa_opmesh_p(igroup,ival+1,jval  ,kval  )*dx
  c10 = kappa_opmesh_p(igroup,ival  ,jval+1,kval  )*(1.0_dp-dx) + kappa_opmesh_p(igroup,ival+1,jval+1,kval  )*dx
  c01 = kappa_opmesh_p(igroup,ival  ,jval  ,kval+1)*(1.0_dp-dx) + kappa_opmesh_p(igroup,ival+1,jval  ,kval+1)*dx
  c11 = kappa_opmesh_p(igroup,ival  ,jval+1,kval+1)*(1.0_dp-dx) + kappa_opmesh_p(igroup,ival+1,jval+1,kval+1)*dx
  
  ! Second linear interpolation along y
  c0 = c00*(1.0_dp-dy) + c10*dy
  c1 = c01*(1.0_dp-dy) + c11*dy
  
  ! Third linear interpolation along z
  planck_ana = c0*(1.0_dp-dz) + c1*dz
  
  planck_ana = dens*10.0_dp**(planck_ana)

  if(sublimation_kuiper) then
     !# RMR ## Sublimation mimicked by a d/g ratio that decreases as a arctan function centered on Tevap ##
     pi=acos(-1.0d0)
     planck_ana = planck_ana*(0.5d0 - 1./pi*atan(0.01d0*(Tp - Tevap) ) ) & !planck_ana contains the d/g ratio of 0.01
          +dens*0.01d0*(1.0d0-0.01d0*(0.5d0 - 1./pi*atan(0.01d0*(Tp - Tevap) ) )) !=> quasi full gas
  endif

  if (sinks_opt_thin .and. insink) planck_ana = min_optical_depth/(0.5D0**nlevelmax*boxlen*scale_l)
  


end function planck_ana

!##################################################################################################
!##################################################################################################
!##################################################################################################
!##################################################################################################

!  Function ROSSELAND_ANA:
!
!> Compute Rosseland mean opacity.
!<
function rosseland_ana(dens,Tp,Tr,igroup,insink)

  use amr_commons
  use radiation_parameters
  use mod_opacities
  use pm_commons,only:Teff_sink

  implicit none

  integer, intent(in) :: igroup
  real(dp),intent(in) :: dens,Tp,Tr
  logical, intent(in) :: insink

  integer             :: ival,jval,kval
  real(dp)            :: x,y,z,dx,dy,dz
  real(dp)            :: x0,x1,y0,y1,z0,z1
  real(dp)            :: c00,c01,c10,c11,c0,c1
  real(dp)            :: rosseland_ana,pi,Tgd
  real(dp)            :: Tevap ! if sublimation_kuiper
  real(dp)::scale_nH,scale_T2,scale_l,scale_d,scale_t,scale_v
  ! Conversion factor from user units to cgs units
  call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)

  if(sublimation_kuiper) then
     !# RMR #### Sublimation of dust grains as in kuiper+10 ApJ ####
     !### The highest dust temperature is the evaporation temperature
     !### Opacities are taken at this temperature
     !### The input temperature is kept to compute the d/g ratio
     Tgd = Tp
     Tevap = 2000.0d0*dens**0.0195  !! Evaporation temperature
     if(Tp .gt. Tevap) Tgd = Tevap
  endif

  ! compute dust and gas opacities
  x = log10(dens)
  if(sublimation_kuiper) then
     y = log10(Tgd) !! No dust grains above Tevap
  else
     y = log10(Tp)
  endif
  z = log10(Tr)
  if(stellar_photon)then
     if(igroup==1 .and. maxval(Teff_sink).gt.0)z = log10(maxval(Teff_sink)) 
  end if

  ival = floor((x - x_opmesh(1)) / dx_opmesh) + 1
  jval = floor((y - y_opmesh(1)) / dy_opmesh) + 1
  kval = floor((z - z_opmesh(1)) / dz_opmesh) + 1
  
  ! enforce to be in the table
  ival = min(max(ival,1),nx_opmesh)
  jval = min(max(jval,1),ny_opmesh)
  kval = min(max(kval,1),nz_opmesh)

  ! Perform tri-linear interpolation
  
  ! Compute coordinate deltas
  x0 = x_opmesh(ival  )
  x1 = x_opmesh(ival+1)
  y0 = y_opmesh(jval  )
  y1 = y_opmesh(jval+1)
  z0 = z_opmesh(kval  )
  z1 = z_opmesh(kval+1)
  
  dx = (x-x0)/(x1-x0)
  dy = (y-y0)/(y1-y0)
  dz = (z-z0)/(z1-z0)
  
  ! First linear interpolation along x
  c00 = kappa_opmesh_r(igroup,ival  ,jval  ,kval  )*(1.0_dp-dx) + kappa_opmesh_r(igroup,ival+1,jval  ,kval  )*dx
  c10 = kappa_opmesh_r(igroup,ival  ,jval+1,kval  )*(1.0_dp-dx) + kappa_opmesh_r(igroup,ival+1,jval+1,kval  )*dx
  c01 = kappa_opmesh_r(igroup,ival  ,jval  ,kval+1)*(1.0_dp-dx) + kappa_opmesh_r(igroup,ival+1,jval  ,kval+1)*dx
  c11 = kappa_opmesh_r(igroup,ival  ,jval+1,kval+1)*(1.0_dp-dx) + kappa_opmesh_r(igroup,ival+1,jval+1,kval+1)*dx
  
  ! Second linear interpolation along y
  c0 = c00*(1.0_dp-dy) + c10*dy
  c1 = c01*(1.0_dp-dy) + c11*dy
  
  ! Third linear interpolation along z
  rosseland_ana = c0*(1.0_dp-dz) + c1*dz
  
  rosseland_ana = dens*10.0_dp**(rosseland_ana)

  if(sublimation_kuiper) then
     !# RMR ## Sublimation mimicked by a d/g ratio that decreases as a arctan function centered on Tevap ##
     pi=acos(-1.0d0)
     rosseland_ana = rosseland_ana*(0.5d0 - 1./pi*atan(0.01d0*(Tp - Tevap) ) ) & !ross_ana contains the d/g ratio of 0.01
          +dens*0.01d0*(1.0d0-0.01d0*(0.5d0 - 1./pi*atan(0.01d0*(Tp - Tevap) ) )) !=> quasi full gas
  endif

  if (sinks_opt_thin .and. insink) rosseland_ana = min_optical_depth/(0.5D0**nlevelmax*boxlen*scale_l)

end function rosseland_ana

!##################################################################################################
!##################################################################################################
!##################################################################################################
!##################################################################################################

!  Function SCATTERING_ANA:
!
!> This routine computes the scattering opacity kappa_s*rho
!! as a function of density and temperature.
!! Units are supposed to be in cgs here (as in units.f90)
!<
function scattering_ana(dens,Tp,Tr,igroup)

  use amr_commons
  use const

  implicit none

  integer ,intent(in)    :: igroup
  real(dp),intent(in)    :: dens,Tp,Tr
  real(dp)               :: scattering_ana
  
  scattering_ana = zero

end function scattering_ana

!##################################################################################################
!##################################################################################################
!##################################################################################################
!##################################################################################################

!  Subroutine COMPUTE_INTEGRAL:
!
!> Computes integrals for Planck and Rosseland means between nu1 and nu2.
!<
subroutine compute_integral(int1,int2,int3,int4,int5,int6,nu1,nu2,op1,op2,temp)

  use amr_parameters, only : dp

  implicit none
  
  real(dp), intent(inout) :: int1,int2,int3,int4,int5,int6
  real(dp), intent(in   ) :: nu1,nu2,op1,op2,temp
  real(dp)                :: BPlanck,Div_BPlanck

  int1 = int1 + 0.5_dp * (nu2-nu1) * (     BPlanck(nu1,temp) * op1 + &
                                           BPlanck(nu2,temp) * op2 )
  int2 = int2 + 0.5_dp * (nu2-nu1) * (     BPlanck(nu1,temp)       + &
                                           BPlanck(nu2,temp)       )
  int3 = int3 + 0.5_dp * (nu2-nu1) * ( Div_BPlanck(nu1,temp)       + &
                                       Div_BPlanck(nu2,temp)       )
  int4 = int4 + 0.5_dp * (nu2-nu1) * ( Div_BPlanck(nu1,temp) / op1 + &
                                       Div_BPlanck(nu2,temp) / op2 )
  int5 = int5 + 0.5_dp * (nu2-nu1) * ( op1 + op2 )
  int6 = int6 +          (nu2-nu1)

  return

end subroutine compute_integral
../patch/collapse/read_hydro_params.f90
subroutine read_hydro_params(nml_ok)
  use amr_commons
  use hydro_commons
  use radiation_parameters
  use pm_commons
  use cooling_module,ONLY:kB,mH,clight
  use const
  use units_commons
  use mod_opacities
  use cloud_module
  use rt_parameters !hybrid RT
#if NIMHD==1
  use variables_X,ONLY:nvarchimie,nchimie,tchimie,&
      &nminchimie,tminchimie,dnchimie,dtchimie,&
      &xichimie,ximinchimie,dxichimie,&
      nislin,tislin,xiislin
#endif
  implicit none
#ifndef WITHOUTMPI
  include 'mpif.h'
#endif
  logical::nml_ok
  !--------------------------------------------------
  ! Local variables  
  !--------------------------------------------------
  integer::i,j,idim,irad,nboundary_true=0,ht
  integer ,dimension(1:MAXBOUND)::bound_type
  real(dp)::ek_bound,em_bound,er_bound
  real(dp)::radiation_source
  character(len=2):: rad_trans_model='m1'

  integer::ii,jj,kk,ee,hh,gg,ie,ir,k,it
  real(dp)::dummy,compute_db,d0
  real(dp)::xx,yy,vv,ww,zz
  real(dp)::dtemp1,Temp_new2,epsilon_n,eint_old,T0,temp_new,d_loc,eint_new,pi

  real(dp) :: sum_dust
#if NDUST>0
  real(dp),dimension(1:ndust):: dustMRN
  real(dp) :: epsilon_0
  integer ::idust
#endif  
  !--------------------------------------------------
  ! Namelist definitions
  !--------------------------------------------------
  namelist/init_params/filetype,initfile,multiple,nregion,region_type &
       & ,x_center,y_center,z_center,aexp_ini &
       & ,length_x,length_y,length_z,exp_region &
       & ,d_region,u_region,v_region,w_region,p_region &
#if NENER>NGRP
       & ,prad_region &
#endif
#if NGRP>0
       & ,E_region &
#endif
#if NVAR>8+NENER
       & ,var_region &
#endif
#if NDUST>0
       & ,dust_region &
#endif       
       & ,A_region,B_region,C_region &
       & ,alpha_dense_core,beta_dense_core,crit,delta_rho,mass_c,rap,cont &
       & ,ff_sct,ff_rt,ff_act,ff_vct,theta_mag,bb_test &
       & ,contrast,Mach,uniform_bmag,r0_box
  namelist/hydro_params/gamma,courant_factor,smallr,smallc &
       & ,niter_riemann,slope_type,slope_mag_type,switch_solv,switch_solv_dens &
#if NENER>0
       & ,gamma_rad &
#endif
       & ,pressure_fix,beta_fix,scheme,riemann,riemann2d &
       & ,positivity_type
  namelist/refine_params/x_refine,y_refine,z_refine,r_refine &
       & ,a_refine,b_refine,exp_refine,jeans_refine,mass_cut_refine &
       & ,iso_jeans,Tp_jeans &
       & ,m_refine,mass_sph,err_grad_d,err_grad_p,err_grad_u &
       & ,err_grad_A,err_grad_B,err_grad_C,err_grad_B2,err_grad_E &
#if NDUST>0
       & ,err_grad_dust,floor_dust &
#endif        
       & ,floor_d,floor_u,floor_p,ivar_refine,var_cut_refine &
       & ,floor_A,floor_B,floor_C,floor_B2,floor_E &
       & ,interpol_var,interpol_type,sink_refine,interpol_mag_type
  namelist/boundary_params/nboundary,bound_type &
       & ,ibound_min,ibound_max,jbound_min,jbound_max &
       & ,kbound_min,kbound_max &
       & ,d_bound,u_bound,v_bound,w_bound,p_bound &
#if NENER>NGRP
       & ,prad_bound &
#endif
#if NGRP>0
       & ,E_bound &
#endif
#if NDUST>0
       &, dust_bound &
#endif        
#if NVAR>8+NENER
       & ,var_bound &
#endif
       & ,A_bound,B_bound,C_bound,T_bound ,no_inflow
  namelist/physics_params/cooling,haardt_madau,metal,isothermal,barotrop,eos &
       & ,m_star,t_star,n_star,T2_star,g_star,del_star,eps_star,jeans_ncells &
       & ,eta_sn,yield,rbubble,f_ek,ndebris,f_w,mass_gmc,kappa_IR &
       & ,J21,a_spec,z_ave,z_reion,eta_mag,delayed_cooling,T2max &
       & ,self_shielding,smbh,agn,B_ave,t_diss &
!       & ,rsink_max,msink_max,merge_stars &
       & ,units_density,units_time,units_length,neq_chem,ir_feedback,ir_eff &
       & ,larson_lifetime,flux_accretion,t_diss &
       & ,mu_gas,analytical_barotrop
  namelist/radiation_params/grey_rad_transfer,dtdiff_params,dt_control &
       & ,rosseland_params,planck_params,epsilon_diff,fld_limiter &
       & ,freqs_in_Hz,read_groups,split_groups_log,extra_end_group  &
       & ,numin,numax,Tr_floor,robin,rad_trans_model,min_optical_depth,rt_feedback,rt_protostar_m1 &
       & ,PMS_evol,Hosokawa_track,energy_fix,facc_star,facc_star_lum,valp_min,store_matrix,external_radiation_field &
       & ,opacity_type,rad_trans_model,min_optical_depth &
       & ,rt_feedback,PMS_evol,Hosokawa_track,energy_fix &
       & ,facc_star,facc_star_lum,store_matrix &
       & ,external_radiation_field,stellar_photon &
       & ,rt_protostar_fld,sublimation_kuiper,lum_injection &
       & ,sinks_opt_thin
  ! modif nimhd
  namelist/nonidealmhd_params/nambipolar,gammaAD &
       & ,nmagdiffu,etaMD,nhall,rHall,ntestDADM,coefhall &
       & ,coefad, nminitimestep, coefalfven,nmagdiffu2,nambipolar2,nu_sts,coefdtohm &
       & ,rho_threshold,use_x1d,use_x2d,use_x3d,use_res,default_ionisrate
  namelist/pseudovisco_params/nvisco,visco
#if NDUST>0
  namelist/dust_params/grain_size, grain_dens, K_dust, K_drag,dust_diffusion_test,slope_dust,dust_ratio,mrn, size_min, size_max, mrn_index&
       &,reduce_wdust,reduce_tstop,stokes_max,vdust_max,kwok_correction, vmax_barycenter, f_vmax ,vmax_cs,vmax_dust_lim ,update_eint, smalleps,courant_factor_dust, reduce_dfrac
#endif  
  ! fin modif nimhd

  ! Read namelist file
  rewind(1)
  read(1,NML=init_params,END=101)
  goto 102
101 write(*,*)' You need to set up namelist &INIT_PARAMS in parameter file'
  call clean_stop
102 rewind(1)
  if(nlevelmax>levelmin)read(1,NML=refine_params)
  rewind(1)
  if(hydro)read(1,NML=hydro_params)
  rewind(1)
#if USE_FLD==1 || USE_M_1==1
  if(FLD)read(1,NML=radiation_params)
#endif
  rewind(1)
  read(1,NML=boundary_params,END=103)
  simple_boundary=.true.
  goto 104
103 simple_boundary=.false.
104 if(nboundary>MAXBOUND)then
    write(*,*) 'Error: nboundary>MAXBOUND'
    call clean_stop
  end if
  rewind(1)
  read(1,NML=physics_params,END=105)
105 continue

  ! Conversion factor from user units to cgs units (to be done after read physics_params with units_density...)
  call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)

  if(barotrop)fld=.false.

  !------------------------------------------------
  ! set ischeme
  !------------------------------------------------
  SELECT CASE (scheme)
  CASE ('muscl')
    ischeme = 0
  CASE ('induction')
    ischeme = 1

  CASE DEFAULT
    write(*,*)'unknown scheme'
    call clean_stop
  END SELECT
  !------------------------------------------------
  ! set iriemann
  !------------------------------------------------
  SELECT CASE (riemann)
  CASE ('llf')
    iriemann = 0
  CASE ('roe')
    iriemann = 1
  CASE ('hll')
    iriemann = 2
  CASE ('hlld')
    iriemann = 3
  CASE ('upwind')
    iriemann = 4
  CASE ('hydro')
    iriemann = 5

  CASE DEFAULT
    write(*,*)'unknown riemann solver'
    call clean_stop
  END SELECT
  !------------------------------------------------
  ! set iriemann
  !------------------------------------------------
  SELECT CASE (riemann2d)
  CASE ('llf')
    iriemann2d = 0
  CASE ('roe')
    iriemann2d = 1
  CASE ('upwind')
    iriemann2d = 2
  CASE ('hll')
    iriemann2d = 3
  CASE ('hlla')
    iriemann2d = 4
  CASE ('hlld')
    iriemann2d = 5
  CASE DEFAULT
    write(*,*)'unknown 2D riemann solver'
    call clean_stop
  END SELECT

#if NIMHD==1
  ! modif nimhd
  rewind(1)
  read(1,NML=nonidealmhd_params,END=106)
106 continue
  if((nambipolar.ne.0).and.(nambipolar.ne.1)) then
     write(*,*)'Wrong choice for nambipolar'
     call clean_stop
  end if
  if((nmagdiffu.ne.0).and.(nmagdiffu.ne.1)) then
     write(*,*)'Wrong choice for nmagdiffu'
     call clean_stop
  end if
  if((nhall.ne.0).and.(nhall.ne.1)) then
     write(*,*)'Wrong choice for nhall'
     call clean_stop
  end if

  if((nmagdiffu.eq.1).and.(nmagdiffu2.eq.1)) then
     write(*,*)'Wrong choice for nmagdiffu : choose one kind not both'
     call clean_stop
  end if

  if((nambipolar.eq.1).and.(nambipolar2.eq.1)) then
     write(*,*)'Wrong choice for nambipolar : choose one kind not both'
     call clean_stop
  end if

  if( (nambipolar.eq.1) .or. (nambipolar2.eq.1) .or. &
      (nmagdiffu .eq.1) .or. (nmagdiffu2 .eq.1) .or. &
      (nhall.eq.1) )then
     use_nonideal_mhd = .true.
  else
     use_nonideal_mhd = .false.
  endif

  if(myid==1) then
     write(*,*)'!!!!!!!!!!!!!!!  Non Ideal MHD   !!!!!!!!!!!!!!!!'
     write(*,*)'Non ideal MHD parameters'
     write(*,*)'Making a test ? Yes=1 No=0',ntestDADM
     if(nambipolar.eq.1) then
        write(*,*)'Ambipolar diffusion switched ON'
        write(*,*)'Ambipolar diffusion coefficient',gammaAD
        write(*,*)'Ambipolar diffusion time coefficient',coefad
        write(*,*)'Ionisation coefficient',coefionis
        if(nminitimestep.eq.1) then
           write(*,*)'Mini time step switched ON'
           write(*,*)'Mini time step coefficient',coefalfven
        else
           write(*,*)'Mini time step switched OFF'
        endif
     endif
     if(nambipolar2==1) then
        write(*,*)'Ambipolar diffusion switched ON : subcylcing'
        write(*,*)'Ambipolar diffusion coefficient',gammaAD
        write(*,*)'Ambipolar diffusion time coefficient',coefad
        write(*,*)'Ionisation coefficient',coefionis
        if(nminitimestep.eq.1) then
           write(*,*)'Mini time step switched ON'
           write(*,*)'Mini time step coefficient',coefalfven
        else
           write(*,*)'Mini time step switched OFF'
        endif
     endif

     if((nambipolar.eq.0) .and. (nambipolar2 == 0)) write(*,*)'Ambipolar diffusion switched OFF'

     if(nmagdiffu.eq.1)then
        write(*,*)'Magnetic diffusion switched ON : multiple time stepping'
        write(*,*)'Magnetic diffusion coefficient',etaMD
        write(*,*)'Magnetic diffusion  time coefficient',coefohm
     endif
     if(nmagdiffu2.eq.1)then
        write(*,*)'Magnetic diffusion switched ON : subcycling'
        write(*,*)'Magnetic diffusion coefficient',etaMD
        write(*,*)'Magnetic diffusion  time coefficient',coefohm
     endif
     if((nmagdiffu.eq.0).and.(nmagdiffu2.eq.0))write(*,*)'Magnetic diffusion switched OFF'

     if(nhall.eq.1)then
        write(*,*)'Hall effect switched ON'
        write(*,*)'Hall resistivity',rHall
        write(*,*)'Hall effect time coefficient',coefhall
     endif
     if(nhall.eq.0)write(*,*)'Hall effect switched OFF'

    !if(change_solver.eq.1)then             ! change solver is always used in this version
        write(*,*)'Solveur change when the time step becomes too small'
        write(*,*)'switch_solv', switch_solv
    !endif
  endif

  rewind(1)
  read(1,NML=pseudovisco_params,END=107)
107 continue
  if((nvisco.ne.0).and.(nvisco.ne.1)) then
     write(*,*)'Wrong choice for nvisco'
     call clean_stop
  end if

  if(myid==1) then
     write(*,*)'!!!!!!!!! Pseudo Viscosity Parameters  !!!!!!!!!!'
     if(nvisco.eq.1) then
        write(*,*)'Pseudo viscosity switched ON'
        write(*,*)'Pseudo viscosity coefficient',visco
        write(*,*)'Pseudo viscosity time coefficient',coefvisco
     endif

     if(nvisco.eq.0) then
        write(*,*)'Pseudo viscosity switched OFF'
     endif
  endif

  if((nambipolar2.eq.1).or.(nmagdiffu2.eq.1))then
     if(pressure_fix.eqv..false.) then
        write(*,*)'STS needs pressure_fix=.true. to work....'
        call clean_stop
     end if
  end if
#else
  rewind(1)
  read(1,NML=nonidealmhd_params,END=108)
108 continue
  if( (nambipolar.eq.1) .or. (nambipolar2.eq.1) .or. &
       (nmagdiffu .eq.1) .or. (nmagdiffu2 .eq.1) .or. &
       (nhall.eq.1) )then
     if (myid==1) write(*,*)'You must recompile with NIMHD=1 for non-ideal MHD...'
     call clean_stop
  endif
  ! fin modif nimhd
#endif
  
! Modif dust
#if NDUST>0
  rewind(1)
  read(1,NML=dust_params,END=109)
109 continue
  !--------------------------------------------------
  ! Check for dust
  !--------------------------------------------------
  if(npscal<ndust)then
     if(myid==1)write(*,*)'Error: dust need npscal >= ndust'
     if(myid==1)write(*,*)'Modify hydro_parameters.f90 and recompile'
     nml_ok=.false.
  endif
#endif
  ! Fin modif dust
  
#if USE_FLD==1 || USE_M_1==1
  ! Initialize multigroup
  allocate(nu_min_hz(1:ngrp),nu_max_hz(1:ngrp),nu_min_ev(1:ngrp),nu_max_ev(1:ngrp))
  call create_groups
  call tabulate_art4
  call read_omegas
  if(myid==1 .and. grey_rad_transfer .and. ngrp .gt.1) then
     print*,'Warning: Grey Radiation Transfer with NRAD>1'
     call clean_stop
  endif
  scale_E0 = aR*(Tr_floor**4)
  P_cal = scale_E0 / (scale_d * scale_v**2)
  C_cal = clight / scale_v
  is_radiative_energy = .false.
#endif

#if USE_FLD==1
  ! Set i_fld_limiter
  i_fld_limiter=i_fld_limiter_nolim
  if(fld_limiter=='levermore') i_fld_limiter=i_fld_limiter_levermore
  if(fld_limiter=='minerbo')  i_fld_limiter=i_fld_limiter_minerbo
  ! Index array for radiative variables and temperature
  ! Needed in M1 because temperature is stored in uold(:,nvar)
  do irad = 1,nvar_bicg
     ind_bicg (irad) = firstindex_er+irad
     norm_bicg(irad) = P_cal
  enddo
  ind_trad(1) = nvar
  norm_trad(1) = Tr_floor
  do irad = 2,nvar_trad
     ind_trad(irad) = firstindex_er-1+irad
     norm_trad(irad) = P_cal
     is_radiative_energy(irad) = .true.
  enddo


  if(rt_protostar_fld .and. rt_protostar_m1) then
     write(*,*)'Wrong choice for rt_protostar method : choose one kind not both'
     call clean_stop
  end if
#endif

#if USE_M_1==1
  ! Set radiative transfer model
  select case(rad_trans_model)
  case('P1','p1')
     irad_trans_model = irad_trans_model_p1
  case('M1','m1')
     irad_trans_model = irad_trans_model_m1
  case default
     if(myid==1) write(*,*) 'unknown radiative transfer model: '//rad_trans_model
     call clean_stop
  end select
  call compute_valp
  ! Index array for radiative variables and temperature
  ! Needed in M1 because temperature is stored in uold(:,nvar)
  ind_bicg(1) = nvar
  norm_bicg(1) = Tr_floor
  do irad = 2,nvar_bicg
     ind_bicg(irad) = firstindex_er-1+irad
     norm_bicg(irad) = P_cal
  enddo
  do irad = ngrp+2,nvar_bicg
     norm_bicg(irad) = norm_bicg(irad)*C_cal
  enddo
  ind_trad=ind_bicg
  norm_trad=norm_bicg
  is_radiative_energy(2:ngrp+1) = .true.
#endif

  ! Compute the size of the box early,
  ! to avoid problems in the initial build of the amr grid
  call calc_boxlen

  !--------------------------------------------------
  ! Make sure virtual boundaries are expanded to 
  ! account for staggered mesh representation
  !--------------------------------------------------
  nexpand_bound=2

  !--------------------------------------------------
  ! Check for star formation
  !--------------------------------------------------
  if(t_star>0)then
     star=.true.
     pic=.true.
  else if(eps_star>0)then
     t_star=0.1635449*(n_star/0.1)**(-0.5)/eps_star
     star=.true.
     pic=.true.
  endif

  !--------------------------------------------------
  ! Check for metal
  !--------------------------------------------------
  if(metal.and.nvar<(ndim+6))then
     if(myid==1)write(*,*)'Error: metals need nvar >= ndim+6'
     if(myid==1)write(*,*)'Modify hydro_parameters.f90 and recompile'
     nml_ok=.false.
  endif

  !--------------------------------------------------
  ! Check for non-thermal energies
  !--------------------------------------------------
#if NENER>NGRP
  if(nvar<(8+nent))then
     if(myid==1)write(*,*)'Error: non-thermal energy need nvar >= 8+nent'
     if(myid==1)write(*,*)'Modify NENER and recompile'
     nml_ok=.false.
  endif
#endif
  !--------------------------------------------------
  ! Check for radiative variables
  !--------------------------------------------------
#if NGRP>0
#if USE_FLD==1
  if(nvar<(8+nener))then
     if(myid==1)write(*,*)'Error: radiative energies need nvar >= 8+nent+ngrp'
#else
  if(nvar<(8+nener+nfr))then
     if(myid==1)write(*,*)'Error: radiative variables need nvar >= 8+nent+ngrp+nfr'
#endif
     if(myid==1)write(*,*)'Modify NENER, NGRP and recompile'
     nml_ok=.false.
  endif
#endif

  !-------------------------------------------------
  ! This section deals with hydro boundary conditions
  !-------------------------------------------------
  if(simple_boundary.and.nboundary==0)then
     simple_boundary=.false.
  endif

  if (simple_boundary)then

     ! Compute new coarse grid boundaries
     do i=1,nboundary
        if(ibound_min(i)*ibound_max(i)==1.and.ndim>0.and.bound_type(i)>0)then
           nx=nx+1
           if(ibound_min(i)==-1)then
              icoarse_min=icoarse_min+1
              icoarse_max=icoarse_max+1
           end if
           nboundary_true=nboundary_true+1
        end if
     end do
     do i=1,nboundary
        if(jbound_min(i)*jbound_max(i)==1.and.ndim>1.and.bound_type(i)>0)then
           ny=ny+1
           if(jbound_min(i)==-1)then
              jcoarse_min=jcoarse_min+1
              jcoarse_max=jcoarse_max+1
           end if
           nboundary_true=nboundary_true+1
        end if
     end do
     do i=1,nboundary
        if(kbound_min(i)*kbound_max(i)==1.and.ndim>2.and.bound_type(i)>0)then
           nz=nz+1
           if(kbound_min(i)==-1)then
              kcoarse_min=kcoarse_min+1
              kcoarse_max=kcoarse_max+1
           end if
           nboundary_true=nboundary_true+1
        end if
     end do

     ! Compute boundary geometry
     do i=1,nboundary
        if(ibound_min(i)*ibound_max(i)==1.and.ndim>0.and.bound_type(i)>0)then
           if(ibound_min(i)==-1)then
              ibound_min(i)=icoarse_min+ibound_min(i)
              ibound_max(i)=icoarse_min+ibound_max(i)
              if(bound_type(i)==1)boundary_type(i)=1
              if(bound_type(i)==2)boundary_type(i)=11
              if(bound_type(i)==3)boundary_type(i)=21
           else
              ibound_min(i)=icoarse_max+ibound_min(i)
              ibound_max(i)=icoarse_max+ibound_max(i)
              if(bound_type(i)==1)boundary_type(i)=2
              if(bound_type(i)==2)boundary_type(i)=12
              if(bound_type(i)==3)boundary_type(i)=22
           end if
           if(ndim>1)jbound_min(i)=jcoarse_min+jbound_min(i)
           if(ndim>1)jbound_max(i)=jcoarse_max+jbound_max(i)
           if(ndim>2)kbound_min(i)=kcoarse_min+kbound_min(i)
           if(ndim>2)kbound_max(i)=kcoarse_max+kbound_max(i)
        else if(jbound_min(i)*jbound_max(i)==1.and.ndim>1.and.bound_type(i)>0)then
           ibound_min(i)=icoarse_min+ibound_min(i)
           ibound_max(i)=icoarse_max+ibound_max(i)
           if(jbound_min(i)==-1)then
              jbound_min(i)=jcoarse_min+jbound_min(i)
              jbound_max(i)=jcoarse_min+jbound_max(i)
              if(bound_type(i)==1)boundary_type(i)=3
              if(bound_type(i)==2)boundary_type(i)=13
              if(bound_type(i)==3)boundary_type(i)=23
           else
              jbound_min(i)=jcoarse_max+jbound_min(i)
              jbound_max(i)=jcoarse_max+jbound_max(i)
              if(bound_type(i)==1)boundary_type(i)=4
              if(bound_type(i)==2)boundary_type(i)=14
              if(bound_type(i)==3)boundary_type(i)=24
           end if
           if(ndim>2)kbound_min(i)=kcoarse_min+kbound_min(i)
           if(ndim>2)kbound_max(i)=kcoarse_max+kbound_max(i)
        else if(kbound_min(i)*kbound_max(i)==1.and.ndim>2.and.bound_type(i)>0)then
           ibound_min(i)=icoarse_min+ibound_min(i)
           ibound_max(i)=icoarse_max+ibound_max(i)
           jbound_min(i)=jcoarse_min+jbound_min(i)
           jbound_max(i)=jcoarse_max+jbound_max(i)
           if(kbound_min(i)==-1)then
              kbound_min(i)=kcoarse_min+kbound_min(i)
              kbound_max(i)=kcoarse_min+kbound_max(i)
              if(bound_type(i)==1)boundary_type(i)=5
              if(bound_type(i)==2)boundary_type(i)=15
              if(bound_type(i)==3)boundary_type(i)=25
           else
              kbound_min(i)=kcoarse_max+kbound_min(i)
              kbound_max(i)=kcoarse_max+kbound_max(i)
              if(bound_type(i)==1)boundary_type(i)=6
              if(bound_type(i)==2)boundary_type(i)=16
              if(bound_type(i)==3)boundary_type(i)=26
           end if
        end if
     end do
     do i=1,nboundary
        ! Check for errors
        if( (ibound_min(i)<0.or.ibound_max(i)>(nx-1)) .and. (ndim>0) .and.bound_type(i)>0 )then
           if(myid==1)write(*,*)'Error in the namelist'
           if(myid==1)write(*,*)'Check boundary conditions along X direction',i
           nml_ok=.false.
        end if
        if( (jbound_min(i)<0.or.jbound_max(i)>(ny-1)) .and. (ndim>1) .and.bound_type(i)>0)then
           if(myid==1)write(*,*)'Error in the namelist'
           if(myid==1)write(*,*)'Check boundary conditions along Y direction',i
           nml_ok=.false.
        end if
        if( (kbound_min(i)<0.or.kbound_max(i)>(nz-1)) .and. (ndim>2) .and.bound_type(i)>0)then
           if(myid==1)write(*,*)'Error in the namelist'
           if(myid==1)write(*,*)'Check boundary conditions along Z direction',i
           nml_ok=.false.
        end if
     end do
  end if
  nboundary=nboundary_true
  if(simple_boundary.and.nboundary==0)then
     simple_boundary=.false.
  endif

  !--------------------------------------------------
  ! Compute boundary conservative variables
  !--------------------------------------------------
  do i=1,nboundary
     ! Do imposed BC for radiative transfer
     d0=compute_db()
     d_bound(i)=d0
      sum_dust=0.0d0
#if NDUST>0
    epsilon_0 = dust_ratio(1)
     do idust =1,ndust
        dustMRN(idust) = dust_ratio(idust)/(1.0d0+dust_ratio(idust))
     end do
     if(mrn) call init_dust_ratio(epsilon_0, dustMRN)
     do j=1,ndust
        sum_dust = sum_dust + dustMRN(j)
     end do
     do j=1,ndust
        boundary_var(i,firstindex_ndust+j)=d_bound(i)*dustMRN(j)
     end do
#endif
     T_bound(i)=Tr_floor
     P_bound(i)=T_bound(i)*d_bound(i)*(1.0_dp-sum_dust)*kb/(mu_gas*mH*scale_v**2)
     
     boundary_var(i,1)=MAX(d_bound(i),smallr)
     boundary_var(i,2)=d_bound(i)*u_bound(i)
     boundary_var(i,3)=d_bound(i)*v_bound(i)
     boundary_var(i,4)=d_bound(i)*w_bound(i)
     boundary_var(i,6)=A_bound(i)
     boundary_var(i,7)=B_bound(i)
     boundary_var(i,8)=C_bound(i)
     boundary_var(i,nvar+1)=A_bound(i)
     boundary_var(i,nvar+2)=B_bound(i)
     boundary_var(i,nvar+3)=C_bound(i)

     er_bound=0.0D0
#if NENER>0
     do j=1,nent
        boundary_var(i,firstindex_er+j)=prad_bound(i,j)
        er_bound=er_bound+boundary_var(i,8+j)/(gamma_rad(j)-1.0d0)
     end do
#endif
#if USE_FLD==1 || USE_M_1==1
     !     T_bound(i)=P_bound(i)*mu_gas*mH/kb/d_bound(i) *scale_v**2
     call temperature_eos(d_bound(i)*(1.0_dp-sum_dust),P_bound(i)/(gamma-1.0d0),T_bound(i),ht)
     do j=1,ngrp
        boundary_var(i,firstindex_er+j)=radiation_source(T_bound(i),j)/(scale_d*scale_v**2)
        er_bound=er_bound+boundary_var(i,firstindex_er+j)
#if USE_M_1==1
        !Radiative fluxes
                   boundary_var(i,firstindex_er+  ngrp+j)=boundary_var(i,firstindex_er+j)*clight/scale_v*fx_bound(i,j)
        if(ndim>1) boundary_var(i,firstindex_er+2*ngrp+j)=boundary_var(i,firstindex_er+j)*clight/scale_v*fy_bound(i,j)
        if(ndim>2) boundary_var(i,firstindex_er+3*ngrp+j)=boundary_var(i,firstindex_er+j)*clight/scale_v*fz_bound(i,j)
#endif
     end do
#endif

     ek_bound=0.5d0*d_bound(i)*(u_bound(i)**2+v_bound(i)**2+w_bound(i)**2)
     em_bound=0.5d0*(A_bound(i)**2+B_bound(i)**2+C_bound(i)**2)
     boundary_var(i,5)=ek_bound+em_bound+er_bound+P_bound(i)/(gamma-1.0d0)
  end do

  !-----------------------------------
  ! Rearrange level dependent arrays
  !-----------------------------------
  do i=nlevelmax,levelmin,-1
     jeans_refine(i)=jeans_refine(i-levelmin+1)
  end do
  do i=1,levelmin-1
     jeans_refine(i)=-1.0
  end do

  !-----------------------------------
  ! Sort out passive variable indices
  !-----------------------------------
  inener=9 ! MUST BE THIS VALUE !!! RT variable
  imetal=firstindex_pscal+1
  lastindex_pscal=nvar
  if(energy_fix)lastindex_pscal=nvar-1
  idelay=imetal
  if(metal)idelay=imetal+1
  ivirial1=idelay
  ivirial2=idelay
  if(delayed_cooling)then
     ivirial1=idelay+1
     ivirial2=idelay+1
  endif
  if(sf_virial)then
     if(sf_compressive) ivirial2=ivirial1+1
  endif
  ixion=ivirial2
  if(delayed_cooling)ixion=ivirial2+1
  ichem=ixion
  if(aton)ichem=ixion+1

  !-----------------------------------
  ! Set magnetic slope limiters
  !-----------------------------------
  if (slope_mag_type == -1) then
    slope_mag_type = slope_type
  endif
  if (interpol_mag_type == -1) then
    interpol_mag_type = interpol_type
  endif

#if NIMHD==1
  !------------------------------------------
  ! Read resistivity tables for non-ideal MHD
  !------------------------------------------
  if(use_nonideal_mhd)then
     if(use_res==1)then
        open(10,file='res_sig.dat', status='old')
        read(10,*) nchimie
        allocate(resistivite_chimie_res(8,nchimie))
        do i=1,nchimie
           read(10,*)resistivite_chimie_res(:,i)
        end do
        close(10)
        rho_threshold=max(rho_threshold,resistivite_chimie_res(1,1)*(mu_gas*mH)/scale_d) ! input in part/cc, output in code units
        resistivite_chimie_res(7,:)=resistivite_chimie_res(7,:)*clight**2/(4.d0*acos(-1.))
        resistivite_chimie_res(6,:)=1.43d-7**2/(&
        &max(resistivite_chimie_res(6,:)*((1.0d0-tanh(resistivite_chimie_res(1,:)/5.0d13))),1.e-36)&
        &*3.d-16*sqrt(resistivite_chimie_res(1,:))*(2.34d-24**1.5)*clight**2)
        !     open(1010,file='res_sig_v.dat', status='new')
        nminchimie=(resistivite_chimie_res(1,1))
        dnchimie=(log10(resistivite_chimie_res(1,nchimie))-log10(resistivite_chimie_res(1,1)))/&
                 &(nchimie-1)
!                 print*, dnchimie,17.d0/35.d0
        !     do i=1,nchimie
        !     write(1010,*)resistivite_chimie(1,i),resistivite_chimie(6,i)
        !  end do
        !     close(1010)
        !     stop
     else if(use_x2d==1)then
        open(42,file='resnh.dat', status='old')
        read(42,*) nchimie, tchimie, nvarchimie
        read(42,*)
        read(42,*)
        allocate(resistivite_chimie_x(-1:nvarchimie,nchimie,tchimie,1))
        do i=1,tchimie
           do j=1,nchimie
              read(42,*)resistivite_chimie_x(0:nvarchimie,j,i,1),dummy,dummy,dummy,dummy,resistivite_chimie_x(-1,j,i,1)
!              print *, resistivite_chimie_x(:,j,i)
           end do
           read(42,*)
        end do
        close(42)
        rho_threshold=max(rho_threshold,resistivite_chimie_x(0,1,1,1)*(mu_gas*mH)/scale_d) ! input in part/cc, output in code units
        nminchimie=(resistivite_chimie_x(0,1,1,1))
        dnchimie=(log10(resistivite_chimie_x(0,nchimie,1,1))-log10(resistivite_chimie_x(0,1,1,1)))/&
                 &(nchimie-1)
!                 print*, dnchimie,15.d0/50.d0
        tminchimie=(resistivite_chimie_x(-1,1,1,1))
        dtchimie=(log10(resistivite_chimie_x(-1,1,tchimie,1))-log10(resistivite_chimie_x(-1,1,1,1)))/&
                 &(tchimie-1)
!                 print*, dtchimie,3.d0/50.d0
!         close(333)
        call rq
        call nimhd_3dtable
     else if(use_x3d==1)then

        open(42,file='marchand2016_table.dat',form='unformatted')
        read(42) nchimie, tchimie, xichimie, nvarchimie
        allocate(resistivite_chimie_x(-2:nvarchimie+4,nchimie,tchimie,xichimie))
        read(42) resistivite_chimie_x
        close(42)

        rho_threshold=max(rho_threshold,resistivite_chimie_x(-2,1,1,1)*(mu_gas*mH)/scale_d) ! input in part/cc, output in code units
        nminchimie=(resistivite_chimie_x(-2,1,1,1))
        dnchimie=(log10(resistivite_chimie_x(-2,nchimie,1,1))-log10(resistivite_chimie_x(-2,1,1,1)))/&
                 &(nchimie-1)
!                 print*, dnchimie,15.d0/50.d0
        tminchimie=(resistivite_chimie_x(-1,1,1,1))
        dtchimie=(log10(resistivite_chimie_x(-1,1,tchimie,1))-log10(resistivite_chimie_x(-1,1,1,1)))/&
                 &(tchimie-1)
!                 print*, dtchimie,3.d0/50.d0
        ximinchimie=(resistivite_chimie_x(0,1,1,1))
        dxichimie=(log10(resistivite_chimie_x(0,1,1,xichimie))-log10(resistivite_chimie_x(0,1,1,1)))/&
                 &(xichimie-1)
        call rq_3d
        call nimhd_4dtable
     else
        print*, 'must choose an input for abundances or resistivities'
        stop
     endif
  endif
#endif

  if(barotrop)fld=.false.

  if(barotrop .and. (.not. analytical_barotrop))then
     open(101,file='barotropic_eos.dat', status='old')
     read(101,*)nrho_barotrop,rhomin_barotrop,rhomax_barotrop,drho_barotrop
     allocate(rho_barotrop(nrho_barotrop))
     allocate(temp_barotrop(nrho_barotrop))
     do i=1,nrho_barotrop
        read(101,*)rho_barotrop(i),temp_barotrop(i)
     end do
     close(101)
  end if

  if(eos)then
  
     !--------------------------------
     ! Read eos tables
     !--------------------------------
!      open(14,file='verif.dat')
     open(10,file='tab_eos.dat',status='old',form='unformatted')
     read(10) nRho,nEnergy
     read(10) rhomin,rhomax,emin,Emax,yHe
     
     allocate(Rho_eos(nRho,nEnergy),Ener_eos(nRho,nEnergy),Temp_eos(nRho,nEnergy),P_eos(nRho,nEnergy))
     allocate(  Cs_eos(nRho,nEnergy),S_eos(nRho,nEnergy),  xH_eos(nRho,nEnergy), xH2_eos(nRho,nEnergy)                  )
     allocate(xHe_eos(nRho,nEnergy),xHep_eos(nRho,nEnergy),Cv_eos(nRho,nEnergy)                                       )
     !inversion de la table eos
     nTemp=nEnergy
     allocate(eint_eos(nRho,nTemp))
     
     read(10)  rho_eos
     read(10) Ener_eos
     read(10) Temp_eos
     read(10)    P_eos
     read(10)    S_eos
     read(10)   Cs_eos
     read(10)   xH_eos
     read(10)  xH2_eos
     read(10)  xHe_eos
     read(10) xHep_eos
     close(10)
     
     rho_eos(:,:) = log10(rho_eos(:,:))
     ener_eos(:,:) = log10(ener_eos(:,:))
     
     do k=1,5
        ii=0
        jj=0
        kk=0
        hh=0
        ee=0
        gg=0
        do ir=2,nRho-1
           do ie=2,nEnergy-1
              if (P_eos(ir,ie) .eq. 0.0d0) then
                 ii = ii+1
                 xx = P_eos(ir,ie+1) * P_eos(ir,ie-1) *  P_eos(ir-1,ie) * P_eos(ir+1,ie)
                 yy = P_eos(ir+1,ie+1) * P_eos(ir+1,ie-1) *  P_eos(ir-1,ie-1) * P_eos(ir-1,ie+1)
                 if(ie > 2 .and. ie < nEnergy-1 .and. ir > 2 .and. ir < nRho-1)then
                    ww = P_eos(ir,ie+2) * P_eos(ir,ie-2) *  P_eos(ir-2,ie) * P_eos(ir+2,ie)
                 else
                    ww = 0.0_dp
                 endif
                 if(ie > 3 .and. ie < nEnergy-2 .and. ir > 3 .and. ir < nRho-2)then
                    zz = P_eos(ir+3,ie+3) * P_eos(ir-3,ie-3) *  P_eos(ir-3,ie+3) * P_eos(ir+3,ie-3)
                 else
                    zz = 0.0_dp
                 endif
                 if (xx .ne. 0.) then
                    P_eos(ir,ie) = 0.25d0*(P_eos(ir,ie+1) + P_eos(ir,ie-1) + P_eos(ir-1,ie) + P_eos(ir+1,ie))
                    jj=jj+1              
                 else if (yy .ne. 0. .and. k > 0) then
                    P_eos(ir,ie) = 0.25d0*(P_eos(ir+1,ie+1) + P_eos(ir+1,ie-1) + P_eos(ir-1,ie+1)+P_eos(ir-1,ie-1))
                    kk=kk+1
                 else if (ww .ne. 0 .and. k > 1) then
                    ee = ee +1
                    P_eos(ir,ie) = 0.25d0*(P_eos(ir,ie+2) + P_eos(ir,ie-2) + P_eos(ir-2,ie) + P_eos(ir+2,ie))
                 else if (zz .ne. 0 .and. k > 2) then
                    hh=hh+1
                    P_eos(ir,ie) = 0.25d0*(P_eos(ir+3,ie+3) + P_eos(ir+3,ie-3) + P_eos(ir-3,ie+3)+P_eos(ir-3,ie-3))
                 else 
                    gg=gg+1
                 endif
              endif
           enddo
        end do
        if (myid == 1) print*, 'on bouche les trous P_eos', ii,jj,kk,ee,hh,gg, 'iter', k
     end do
     
     do k=1,5
        ii=0
        jj=0
        kk=0
        hh=0
        ee=0
        gg=0
        do ir=2,nRho-1
           do ie=2,nEnergy-1
              if (Cs_eos(ir,ie) .eq. 0.0d0) then           
                 ii = ii+1
                 xx = Cs_eos(ir,ie+1) * Cs_eos(ir,ie-1) *  Cs_eos(ir-1,ie) * Cs_eos(ir+1,ie)
                 yy = Cs_eos(ir+1,ie+1) * Cs_eos(ir+1,ie-1) *  Cs_eos(ir-1,ie-1) * Cs_eos(ir-1,ie+1)
                 if(ie > 2 .and. ie < nEnergy-1 .and. ir > 2 .and. ir < nRho-1)then
                    ww = Cs_eos(ir,ie+2) * Cs_eos(ir,ie-2) *  Cs_eos(ir-2,ie) * Cs_eos(ir+2,ie)
                 else
                    ww = 0.0_dp
                 endif
                 if(ie > 3 .and. ie < nEnergy-2 .and. ir > 3 .and. ir < nRho-2)then
                    zz = Cs_eos(ir+3,ie+3) * Cs_eos(ir-3,ie-3) *  Cs_eos(ir-3,ie+3) * Cs_eos(ir+3,ie-3)
                 else
                    zz = 0.0_dp
                 endif
                 if (xx .ne. 0.) then
                    Cs_eos(ir,ie) = 0.25d0*(Cs_eos(ir,ie+1) + Cs_eos(ir,ie-1) + Cs_eos(ir-1,ie) + Cs_eos(ir+1,ie))
                    jj=jj+1              
                 else if (yy .ne. 0. .and. k > 0) then
                    Cs_eos(ir,ie) = 0.25d0*(Cs_eos(ir+1,ie+1) + Cs_eos(ir+1,ie-1) + Cs_eos(ir-1,ie+1)+Cs_eos(ir-1,ie-1))
                    kk=kk+1
                 else if (ww .ne. 0 .and. k > 1) then
                    ee = ee +1
                    Cs_eos(ir,ie) = 0.25d0*(Cs_eos(ir,ie+2) + Cs_eos(ir,ie-2) + Cs_eos(ir-2,ie) + Cs_eos(ir+2,ie))
                 else if (zz .ne. 0 .and. k > 2) then
                    hh=hh+1
                    Cs_eos(ir,ie) = 0.25d0*(Cs_eos(ir+3,ie+3) + Cs_eos(ir+3,ie-3) + Cs_eos(ir-3,ie+3)+Cs_eos(ir-3,ie-3))
                 else 
                    gg=gg+1
                 endif
              endif
           enddo
        end do
        if (myid == 1) print*, 'on bouche les trous Cs_eos', ii,jj,kk,ee,hh,gg, 'iter', k
     end do
     
     do k=1,5
        ii=0
        jj=0
        kk=0
        hh=0
        ee=0
        gg=0
        do ir=2,nRho-1
           do ie=2,nEnergy-1
              if (Temp_eos(ir,ie) .eq. 0.0d0) then           
                 ii = ii+1
                 xx = Temp_eos(ir,ie+1) * Temp_eos(ir,ie-1) *  Temp_eos(ir-1,ie) * Temp_eos(ir+1,ie)
                 yy = Temp_eos(ir+1,ie+1) * Temp_eos(ir+1,ie-1) *  Temp_eos(ir-1,ie-1) * Temp_eos(ir-1,ie+1)
                 if(ie > 2 .and. ie < nEnergy-1 .and. ir > 2 .and. ir < nRho-1)then
                    ww = Temp_eos(ir,ie+2) * Temp_eos(ir,ie-2) *  Temp_eos(ir-2,ie) * Temp_eos(ir+2,ie)
                 else
                    ww = 0.0_dp
                 endif
                 if(ie > 3 .and. ie < nEnergy-2 .and. ir > 3 .and. ir < nRho-2)then
                    zz = Temp_eos(ir+3,ie+3) * Temp_eos(ir-3,ie-3) *  Temp_eos(ir-3,ie+3) * Temp_eos(ir+3,ie-3)
                 else
                    zz = 0.0_dp
                 endif
                 if (xx .ne. 0.) then
                    Temp_eos(ir,ie) = 0.25d0*(Temp_eos(ir,ie+1)+Temp_eos(ir,ie-1)+Temp_eos(ir-1,ie)+Temp_eos(ir+1,ie))
                    jj=jj+1              
                 else if (yy .ne. 0. .and. k > 0) then
                    Temp_eos(ir,ie) = 0.25d0*(Temp_eos(ir+1,ie+1)+Temp_eos(ir+1,ie-1)+Temp_eos(ir-1,ie+1)+Temp_eos(ir-1,ie-1))
                    kk=kk+1
                 else if (ww .ne. 0 .and. k > 1) then
                    ee = ee +1
                    Temp_eos(ir,ie) = 0.25d0*(Temp_eos(ir,ie+2)+Temp_eos(ir,ie-2)+Temp_eos(ir-2,ie)+Temp_eos(ir+2,ie))
                 else if (zz .ne. 0 .and. k > 2) then
                    hh=hh+1
                    Temp_eos(ir,ie) = 0.25d0*(Temp_eos(ir+3,ie+3)+Temp_eos(ir+3,ie-3)+Temp_eos(ir-3,ie+3)+Temp_eos(ir-3,ie-3))
                 else 
                    gg=gg+1
                 endif
              endif
           enddo
        end do
        
        if (myid == 1) print*, 'on bouche les trous Temp_eos', ii,jj,kk,ee,hh,gg, 'iter', k
     end do
     
     Tmin=3.0d0
     Tmax=1.0d5
     dtemp1 =(log10(Tmax) - log10(Tmin))/ntemp
     eint_eos(:,:)=0.0d0
     do ir=2,nRho-1
        do it=1,ntemp
           d_loc = (10.**rho_eos(ir,1))
           T0 = 10.**(log10(Tmin) + (it-1.0d0)*dtemp1)
           
           eint_old = d_loc*kb*T0/(mu_gas*mh*(gamma-1.0d0))
           if (it >1) then
              eint_old = max(d_loc*kb*T0/(mu_gas*mh*(gamma-1.0d0)),eint_eos(ir,it-1))
           end if
           
           epsilon_n = 1.0d0
           
           do ii=1,1000
              call temperature_eos(d_loc/scale_d,eint_old/(scale_d*scale_v**2),temp_new,ht)
              if (ht==1) then
                 eint_old=0.d0
                 exit
              end if
              call temperature_eos(d_loc/scale_d,eint_old*1.001_dp/(scale_d*scale_v**2),temp_new2,ht)
              if (ht==1) then
                 eint_old=0.d0
                 exit
              end if
              
              if(abs(Temp_new2-Temp_new) .ne.0)then
                 eint_new = eint_old - (Temp_new-T0)/((Temp_new2-Temp_new)/(0.001*eint_old))
              else
                 eint_new = eint_old
              endif
              epsilon_n = abs(eint_new - eint_old)/eint_old
              eint_old = eint_new
              if  (abs(epsilon_n) .lt. 1.d-4) then
                 exit
              else if (ii==1000) then
                 print*, 'newton for e(rho,T) did not converge at ', log10(d_loc),log10(T0)
              end if
           end do
           eint_eos(ir,it) = eint_old 
        enddo
     enddo
     
     Cv_eos(:,:)=0.0d0
     
     do  ir=2,nRho-1
        do  ie=2,nEnergy-1
           d_loc = (10.**rho_eos(ir,1))
           T0 = 10.**(ener_eos(ir,ie))
           
           call temperature_eos(d_loc/scale_d,(T0-0.001_dp*T0)/(scale_d*scale_v**2),temp_new,ht)
           call temperature_eos(d_loc/scale_d,(T0+0.001_dp*T0)/(scale_d*scale_v**2),temp_new2,ht)
           
           if((temp_new2-temp_new) .ne. 0.0_dp)then
              Cv_eos(ir,ie)=(0.002_dp*T0)/(temp_new2-temp_new)
           else
              Cv_eos(ir,ie) = 1.0_dp
           endif
        end do
     end do
     Cv_eos(:,nEnergy)=Cv_eos(:,nEnergy-1)
     
     if (myid == 1) print*, 'ok pour le bouchage'
  end if

  ! Multigroup opacities initialization
  if(fld)then
     if((opacity_type == 'grey') .and. (ngrp > 1) .and. (.not.stellar_photon))then
        if(myid == 1)then
           write(*,*) 'WARNING! Trying to use grey opacity table with ngrp =',ngrp
           write(*,*) 'Switching to multigroup opacities'
        endif
        opacity_type = 'multigroup'
     endif
     call init_opacities
  end if
 
  if(PMS_evol .and. rt_feedback .and. Hosokawa_track)then
     open(101,file='Hosokawa_track.dat', status='old')
     read(101,*)nmdot_PMS,nm_PMS,ndata_PMS
     allocate(nb_ligne_PMS(nmdot_PMS))
     allocate(data_PMS(nmdot_PMS,nm_PMS,ndata_PMS))
     read(101,*)nb_ligne_PMS(1),nb_ligne_PMS(2),nb_ligne_PMS(3),nb_ligne_PMS(4),nb_ligne_PMS(5)
     do i=1,nmdot_PMS
        do j=1,nm_PMS
           read(101,*)data_PMS(i,j,1),data_PMS(i,j,2),data_PMS(i,j,3),data_PMS(i,j,4) ! mdot,mass,luminosity,radius
        end do
     end do
     close(101)
  end if

end subroutine read_hydro_params
!################################################################
!################################################################
!################################################################ 
!################################################################
!   Modification of original codes written by David H. Bailey    
!   This subroutine computes ddb(i) = dda(i)+ddb(i)
subroutine DDPDD (dda, ddb, len, itype)
use amr_commons
  implicit none
  real(dp):: e, t1, t2
  integer i, len, itype
!  complex*16:: dda(len), ddb(len)
  complex*16:: dda, ddb
!  print*,dda,ddb
  do i = 1, len
     !   Compute dda + ddb using Knuth's trick.
     t1 = real(dda) + real(ddb)
     e = t1 - real(dda)
!!      t1 = real(dda(i)) + real(ddb(i))
!!      e = t1 - real(dda(i))
     t2 = ((real(ddb) - e) + (real(dda) - (t1 - e)))&
     &     +imag(dda) + imag(ddb)
!!      t2 = ((real(ddb(i)) - e) + (real(dda(i)) - (t1 - e)))&
!!      &     +imag(dda(i)) + imag(ddb(i))
!!  !    print*,t1,t2
     !   The result is t1 + t2, after normalization.
!!      ddb(i) = cmplx ( t1 + t2, t2 - ((t1 + t2) - t1) )
     ddb = cmplx ( t1 + t2, t2 - ((t1 + t2) - t1),dp)
  enddo
  
  return
end subroutine DDPDD
../patch/collapse/units.f90
subroutine units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)
  use amr_commons
  use hydro_commons
  use cooling_module
  use units_commons, only : scale_kappa,scale_m
  use radiation_parameters, only : mu_gas
  use rt_parameters, only: rt_protostar_m1

  implicit none

  real(dp)::scale_nH,scale_T2,scale_t,scale_v,scale_d,scale_l
  real(dp)::pc
  
  !-----------------------------------------------------------------------
  ! Conversion factors from user units into cgs units
  ! For gravity runs, make sure that G=1 in user units.
  !-----------------------------------------------------------------------

  !code units are: G=1, rho cm^-3, x pc
  pc = 3.08e18_dp

  ! scale_d converts mass density from user units into g/cc
  !scale_d = units_density
  !if(cosmo) scale_d = omega_m * rhoc *(h0/100.)**2 / aexp**3
  !calculate the initial density
  scale_d = mu_gas*mH

  ! scale_t converts time from user units into seconds
  !scale_t = units_time
  !if(cosmo) scale_t = aexp**2 / (h0*1d5/3.08d24)
  ! scale_t converts time from user units into seconds
  scale_t = 1.0_dp/sqrt(Grav*scale_d)

  ! scale_l converts distance from user units into cm
  !scale_l = units_length
  !if(cosmo) scale_l = aexp * boxlen_ini * 3.08d24 / (h0/100)
  !calculate the initial cloud radius
  scale_l = pc

  ! scale_v converts velocity in user units into cm/s
  scale_v = scale_l / scale_t

  ! scale_T2 converts (P/rho) in user unit into (T/mu) in Kelvin
  !kT = 10. * kB  / G / pc^2 / mpart^2
  scale_T2 = mu_gas**2 * mH**2 * pc**2 * Grav / kb

  ! scale_nH converts rho in user units into nH in H/cc
!  scale_nH = X/(mH*mu) * scale_d
  if(rt_protostar_m1) then
     scale_nH = X/(mH) * scale_d !1.0_dp
  else
     scale_nH = 1.0_dp
  endif

  scale_kappa = 1.0_dp/scale_l
  
  scale_m = scale_d*scale_l**3
  
#if NIMHD==1
  ! modif nimhd
  if(ntestDADM.eq.1) then
      scale_d = 1.0_dp
      scale_l = 1.0_dp
      scale_v = 1.d0
      scale_t = 1.0_dp
  end if
  ! fin modif nimhd
#endif
  
end subroutine units

